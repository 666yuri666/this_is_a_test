<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spread in Aregiya</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #1a0f2e 0%, #0d0818 50%, #050208 100%);
            font-family: 'Inter', sans-serif;
            color: #e8e0d5;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(138, 43, 226, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(75, 0, 130, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-areas:
                "header header header"
                "left-panel canvas right-panel"
                "left-panel bottom bottom";
            grid-template-columns: 280px 1fr 300px;
            grid-template-rows: auto 1fr auto;
            gap: 0;
            z-index: 1;
        }

        /* HEADER */
        #gameHeader {
            grid-area: header;
            background: linear-gradient(180deg, rgba(15, 8, 30, 0.95) 0%, rgba(15, 8, 30, 0.85) 100%);
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 -1px 0 rgba(212, 175, 55, 0.2);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #titleSection {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #gameTitle {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #d4af37 0%, #f4e4a6 50%, #d4af37 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            letter-spacing: 2px;
            margin: 0;
        }

        #turnInfo {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: 600;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            padding: 8px 20px;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
        }

        .menu-button {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
            color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
            padding: 10px 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .menu-button:hover {
            background: rgba(212, 175, 55, 0.2);
            border-color: rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        /* LEFT PANEL */
        #leftPanel {
            grid-area: left-panel;
            background: linear-gradient(135deg, rgba(20, 10, 35, 0.9) 0%, rgba(15, 8, 25, 0.95) 100%);
            border-right: 1px solid rgba(138, 43, 226, 0.2);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.4);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(138, 43, 226, 0.1);
        }

        .panel-title {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
            color: #d4af37;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .resource-display {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .resource-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            transition: all 0.3s ease;
        }

        .resource-item:hover {
            border-color: rgba(212, 175, 55, 0.4);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.1);
        }

        .resource-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #c5b8a5;
        }

        .resource-value {
            font-size: 18px;
            font-weight: 600;
            color: #d4af37;
            text-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
        }

        /* RECRUITMENT */
        .recruitment-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-section.greyed-out {
            opacity: 0.4;
            pointer-events: none;
            filter: grayscale(0.5);
        }

        .panel-section.greyed-out .panel-title {
            color: #7a7a8a;
        }

        /* BUILDING MENU */
        .building-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .build-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 6px;
            font-size: 11px;
            min-height: 70px;
            gap: 4px;
        }

        .building-icon {
            font-size: 24px;
            line-height: 1;
        }

        .building-info {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            justify-content: center;
        }

        .building-name {
            font-size: 11px;
            font-weight: 600;
            text-align: left;
        }

        .building-cost {
            font-size: 10px;
            opacity: 0.8;
            text-align: right;
        }

        .recruit-btn {
            position: relative;
            background: linear-gradient(135deg, rgba(75, 35, 100, 0.6) 0%, rgba(50, 20, 70, 0.6) 100%);
            border: 1px solid rgba(138, 43, 226, 0.4);
            color: #e8e0d5;
            padding: 12px 16px;
            cursor: pointer;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .recruit-btn .unit-icon {
            flex-shrink: 0;
        }

        .recruit-btn .unit-name {
            flex-grow: 1;
            text-align: left;
        }

        .recruit-btn .unit-cost {
            flex-shrink: 0;
            font-size: 12px;
            opacity: 0.9;
            text-align: right;
        }

        .recruit-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(138, 43, 226, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .recruit-btn:hover::before {
            left: 100%;
        }

        .recruit-btn:hover {
            border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3), inset 0 0 20px rgba(138, 43, 226, 0.1);
            transform: translateY(-2px);
        }

        .recruit-btn:active {
            transform: translateY(0);
        }

        .recruit-btn.selected {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4) 0%, rgba(180, 140, 30, 0.4) 100%);
            border-color: rgba(212, 175, 55, 0.6);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
        }

        .recruit-btn.locked {
            background: linear-gradient(135deg, rgba(40, 20, 50, 0.4) 0%, rgba(30, 15, 40, 0.4) 100%);
            border-color: rgba(100, 50, 120, 0.3);
            color: #6a5f7a;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .recruit-btn.locked:hover {
            transform: none;
            box-shadow: none;
        }

        .recruit-btn.locked::before {
            display: none;
        }

        .recruit-btn.can-act {
            background: linear-gradient(135deg, rgba(60, 140, 60, 0.7) 0%, rgba(40, 100, 40, 0.7) 100%) !important;
            border-color: rgba(100, 200, 100, 0.6) !important;
        }

        .recruit-btn.can-act:hover {
            border-color: rgba(100, 200, 100, 0.8) !important;
            box-shadow: 0 0 25px rgba(60, 180, 60, 0.5) !important;
        }

        .recruit-btn.cannot-act {
            background: linear-gradient(135deg, rgba(180, 50, 50, 0.7) 0%, rgba(140, 30, 30, 0.7) 100%) !important;
            border-color: rgba(220, 80, 80, 0.6) !important;
            cursor: not-allowed;
        }

        .recruit-btn.cannot-act:hover {
            transform: none;
            box-shadow: none;
        }

        /* ACTIONS */
        .action-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            position: relative;
            background: linear-gradient(135deg, rgba(60, 100, 60, 0.6) 0%, rgba(40, 70, 40, 0.6) 100%);
            border: 1px solid rgba(100, 180, 100, 0.4);
            color: #e8e0d5;
            padding: 12px 20px;
            cursor: pointer;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            border-color: rgba(100, 180, 100, 0.6);
            box-shadow: 0 0 20px rgba(100, 180, 100, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4) 0%, rgba(180, 140, 30, 0.4) 100%);
            border: 2px solid rgba(212, 175, 55, 0.8);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5), inset 0 0 10px rgba(212, 175, 55, 0.3);
            transform: translateY(0);
        }

        button:disabled {
            background: linear-gradient(135deg, rgba(40, 40, 50, 0.4) 0%, rgba(30, 30, 40, 0.4) 100%);
            border-color: rgba(80, 80, 100, 0.3);
            color: #6a6a7a;
            cursor: not-allowed;
            opacity: 0.5;
        }

        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        /* Button State Colors - Using higher specificity to override defaults */
        button.can-act,
        button#endTurnBtn.can-act,
        button#upgradeBtn.can-act,
        button#splitBtn.can-act {
            background: linear-gradient(135deg, rgba(60, 140, 60, 0.7) 0%, rgba(40, 100, 40, 0.7) 100%) !important;
            border-color: rgba(100, 200, 100, 0.6) !important;
        }

        button#endTurnBtn.can-act {
            animation: pulse-green 2s ease-in-out infinite;
        }

        button.can-act:hover,
        button#endTurnBtn.can-act:hover,
        button#upgradeBtn.can-act:hover,
        button#splitBtn.can-act:hover {
            border-color: rgba(100, 200, 100, 0.8) !important;
            box-shadow: 0 0 25px rgba(60, 180, 60, 0.5) !important;
        }

        button.cannot-act,
        button#endTurnBtn.cannot-act,
        button#upgradeBtn.cannot-act,
        button#splitBtn.cannot-act {
            background: linear-gradient(135deg, rgba(180, 50, 50, 0.7) 0%, rgba(140, 30, 30, 0.7) 100%) !important;
            border-color: rgba(220, 80, 80, 0.6) !important;
            cursor: not-allowed;
        }

        button.cannot-act:hover,
        button#endTurnBtn.cannot-act:hover,
        button#upgradeBtn.cannot-act:hover,
        button#splitBtn.cannot-act:hover {
            transform: none;
            box-shadow: none;
        }

        button.greyed-out,
        button#endTurnBtn.greyed-out,
        button#upgradeBtn.greyed-out,
        button#splitBtn.greyed-out {
            background: linear-gradient(135deg, rgba(60, 60, 70, 0.4) 0%, rgba(40, 40, 50, 0.4) 100%) !important;
            border-color: rgba(80, 80, 90, 0.3) !important;
            color: #7a7a8a !important;
            cursor: not-allowed;
            opacity: 0.6;
        }

        button.greyed-out:hover,
        button#endTurnBtn.greyed-out:hover,
        button#upgradeBtn.greyed-out:hover,
        button#splitBtn.greyed-out:hover {
            transform: none;
            box-shadow: none;
        }

        button.has-idle-units,
        button#endTurnBtn.has-idle-units {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.7) 0%, rgba(180, 140, 30, 0.7) 100%) !important;
            border-color: rgba(212, 175, 55, 0.6) !important;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 15px rgba(60, 180, 60, 0.4); }
            50% { box-shadow: 0 0 30px rgba(60, 180, 60, 0.7); }
        }

        /* Legacy classes for backward compatibility */
        button.no-resources {
            background: linear-gradient(135deg, rgba(180, 50, 50, 0.7) 0%, rgba(140, 30, 30, 0.7) 100%);
            border-color: rgba(220, 80, 80, 0.6);
            cursor: not-allowed;
        }

        button.no-resources:hover {
            transform: none;
            box-shadow: none;
        }

        button.already-moved {
            background: linear-gradient(135deg, rgba(180, 50, 50, 0.7) 0%, rgba(140, 30, 30, 0.7) 100%);
            border-color: rgba(220, 80, 80, 0.6);
            cursor: not-allowed;
        }

        button.already-moved:hover {
            transform: none;
            box-shadow: none;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(139, 71, 137, 0.3); }
            50% { box-shadow: 0 0 25px rgba(139, 71, 137, 0.6); }
        }

        button.upgrade {
            background: linear-gradient(135deg, rgba(153, 50, 204, 0.6) 0%, rgba(100, 30, 140, 0.6) 100%);
            border-color: rgba(153, 50, 204, 0.4);
        }

        button.upgrade:hover {
            border-color: rgba(153, 50, 204, 0.6);
            box-shadow: 0 0 20px rgba(153, 50, 204, 0.3);
        }

        button#endTurnBtn {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4) 0%, rgba(180, 140, 30, 0.4) 100%);
            border-color: rgba(212, 175, 55, 0.5);
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
        }

        button#endTurnBtn:hover {
            border-color: rgba(212, 175, 55, 0.7);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
        }

        /* CANVAS */
        #canvasContainer {
            grid-area: canvas;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgb(15, 10, 25);
            position: relative;
        }

        canvas {
            background: rgb(15, 10, 25);
            cursor: crosshair;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
            display: block;
        }

        /* RIGHT PANEL */
        #rightPanel {
            grid-area: right-panel;
            background: linear-gradient(135deg, rgba(20, 10, 35, 0.9) 0%, rgba(15, 8, 25, 0.95) 100%);
            border-left: 1px solid rgba(138, 43, 226, 0.2);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.4);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #leaderboard {
            position: static;
            background: transparent;
            padding: 0;
            border-radius: 0;
            border: none;
            min-width: auto;
        }

        #leaderboard h3 {
            font-family: 'Cinzel', serif;
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            color: #d4af37;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .faction-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .faction-row:hover {
            border-color: rgba(138, 43, 226, 0.4);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.1);
        }

        .faction-row:last-child {
            margin-bottom: 0;
        }

        .faction-name {
            flex: 1;
            font-weight: 600;
            font-size: 14px;
        }

        .faction-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .faction-units {
            color: #ff8888;
        }

        .faction-gold {
            color: #d4af37;
        }

        .faction-player { color: #66ff66; text-shadow: 0 0 10px rgba(102, 255, 102, 0.3); }
        .faction-ancient { color: #b565ff; text-shadow: 0 0 10px rgba(181, 101, 255, 0.3); }
        .faction-beast { color: #ff9944; text-shadow: 0 0 10px rgba(255, 153, 68, 0.3); }
        .faction-nature { color: #55ff88; text-shadow: 0 0 10px rgba(85, 255, 136, 0.3); }

        .gold { color: #d4af37; }
        .mana { color: #b565ff; }

        /* BOTTOM PANEL */
        #bottomPanel {
            grid-area: bottom;
            background: linear-gradient(180deg, rgba(15, 8, 30, 0.95) 0%, rgba(10, 5, 20, 0.98) 100%);
            border-top: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(138, 43, 226, 0.2);
            padding: 15px 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #selectedInfo {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 16px;
            border-radius: 6px;
            border: 1px solid rgba(138, 43, 226, 0.3);
            min-height: 45px;
            font-size: 14px;
            line-height: 1.5;
            color: #c5b8a5;
            display: flex;
            align-items: center;
        }

        #info {
            color: #8a7a65;
            font-size: 11px;
            text-align: center;
            padding: 4px 0;
            font-weight: 400;
        }

        #queueInfo {
            color: #d4af37;
            font-weight: 600;
            margin-right: 10px;
        }

        /* SUN DIRECTION */
        #sunSection {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
            text-align: center;
            font-size: 13px;
            color: #c5b8a5;
        }

        #sunDirection {
            color: #d4af37;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
        }

        /* GAME OVERLAY */
        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameOverlay.show {
            display: flex;
        }

        .overlay-content {
            background: linear-gradient(135deg, rgba(30, 15, 40, 0.95) 0%, rgba(20, 10, 30, 0.98) 100%);
            padding: 50px;
            border-radius: 16px;
            text-align: center;
            border: 3px solid rgba(204, 51, 51, 0.6);
            box-shadow:
                0 0 60px rgba(204, 51, 51, 0.5),
                inset 0 2px 0 rgba(255, 255, 255, 0.1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.5);
            max-width: 600px;
        }

        .overlay-content h2 {
            font-family: 'Cinzel', serif;
            color: #ff6666;
            font-size: 48px;
            margin: 0 0 25px 0;
            text-shadow: 0 0 20px rgba(255, 102, 102, 0.8), 0 0 40px rgba(255, 68, 68, 0.5);
            letter-spacing: 3px;
        }

        .overlay-content p {
            color: #e8e0d5;
            font-size: 18px;
            margin: 15px 0;
            line-height: 1.7;
        }

        .overlay-content button {
            margin-top: 30px;
            padding: 15px 35px;
            font-size: 16px;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4) 0%, rgba(180, 140, 30, 0.4) 100%);
            border-color: rgba(212, 175, 55, 0.5);
        }

        .overlay-content button:hover {
            border-color: rgba(212, 175, 55, 0.7);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
        }

        /* HELP OVERLAY */
        #helpOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }

        #helpOverlay.show {
            display: flex;
        }

        .help-content {
            background: linear-gradient(135deg, rgba(30, 15, 50, 0.98) 0%, rgba(15, 8, 30, 0.98) 100%);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 12px;
            padding: 30px;
            max-width: 1400px;
            width: 100%;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }

        .help-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            color: #d4af37;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            margin: 0 0 25px 0;
            text-align: center;
            border-bottom: 2px solid rgba(138, 43, 226, 0.4);
            padding-bottom: 15px;
        }

        .help-content .close-hint {
            font-size: 16px;
            color: #8a7a65;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
        }

        .help-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .help-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .help-column h3 {
            font-family: 'Cinzel', serif;
            font-size: 24px;
            color: #d4af37;
            margin: 0 0 10px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
        }

        .help-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .help-section h4 {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            color: #ba8fff;
            margin: 0 0 10px 0;
        }

        .help-section p {
            color: #c5b8a5;
            font-size: 13px;
            line-height: 1.6;
            margin: 6px 0;
        }

        .help-section.story p {
            font-size: 14px;
            line-height: 1.7;
        }

        .help-section p strong {
            color: #d4af37;
        }

        .help-section p em {
            color: #ff6b6b;
            font-style: italic;
        }

        .help-content::-webkit-scrollbar {
            width: 10px;
        }

        .help-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .help-content::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.5);
            border-radius: 5px;
        }

        .help-content::-webkit-scrollbar-thumb:hover {
            background: rgba(138, 43, 226, 0.7);
        }

        @media (max-width: 1200px) {
            .help-columns {
                grid-template-columns: 1fr;
            }
        }

        /* WELCOME MESSAGE */
        #welcomeMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 8, 30, 0.85);
            border: 2px solid rgba(212, 175, 55, 0.6);
            border-radius: 12px;
            padding: 30px 50px;
            font-family: 'Cinzel', serif;
            font-size: 28px;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            z-index: 900;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #welcomeMessage.show {
            opacity: 1;
        }

        #welcomeMessage.fade-out {
            opacity: 0;
        }

        /* SCROLLBAR STYLING */
        #leftPanel::-webkit-scrollbar,
        #rightPanel::-webkit-scrollbar {
            width: 8px;
        }

        #leftPanel::-webkit-scrollbar-track,
        #rightPanel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #leftPanel::-webkit-scrollbar-thumb,
        #rightPanel::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.4);
            border-radius: 4px;
        }

        #leftPanel::-webkit-scrollbar-thumb:hover,
        #rightPanel::-webkit-scrollbar-thumb:hover {
            background: rgba(138, 43, 226, 0.6);
        }

        /* Custom cursors for building placement */
        .cursor-valid {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="none" stroke="%2300FF00" stroke-width="3"/><line x1="16" y1="4" x2="16" y2="12" stroke="%2300FF00" stroke-width="3" stroke-linecap="round"/><line x1="16" y1="20" x2="16" y2="28" stroke="%2300FF00" stroke-width="3" stroke-linecap="round"/><line x1="4" y1="16" x2="12" y2="16" stroke="%2300FF00" stroke-width="3" stroke-linecap="round"/><line x1="20" y1="16" x2="28" y2="16" stroke="%2300FF00" stroke-width="3" stroke-linecap="round"/><circle cx="16" cy="16" r="2" fill="%2300FF00"/></svg>') 16 16, crosshair !important;
        }

        .cursor-invalid {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="none" stroke="%23FF0000" stroke-width="3"/><line x1="10" y1="10" x2="22" y2="22" stroke="%23FF0000" stroke-width="3" stroke-linecap="round"/><line x1="22" y1="10" x2="10" y2="22" stroke="%23FF0000" stroke-width="3" stroke-linecap="round"/></svg>') 16 16, not-allowed !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- HEADER -->
        <div id="gameHeader">
            <div id="titleSection">
                <h1 id="gameTitle">SPREAD IN AREGIYA</h1>
                <div id="turnInfo">Turn 1</div>
            </div>
            <button id="menuBtn" class="menu-button">‚ò∞ Menu</button>
        </div>

        <!-- LEFT PANEL: Resources, Recruitment, Actions -->
        <div id="leftPanel">
            <!-- Resources -->
            <div class="panel-section">
                <h3 class="panel-title">Resources</h3>
                <div class="resource-display">
                    <div class="resource-item">
                        <span class="resource-label">‚öîÔ∏è Units</span>
                        <span class="resource-value" id="unitsCount">3/10</span>
                    </div>
                    <div class="resource-item">
                        <span class="resource-label">üí∞ Gold</span>
                        <span class="resource-value gold" id="goldAmount">10</span>
                    </div>
                </div>
            </div>

            <!-- Recruitment -->
            <div class="panel-section" id="recruitmentPanel">
                <h3 class="panel-title">Recruitment</h3>
                <div class="recruitment-grid">
                    <button id="goblinBtn" class="recruit-btn" onclick="selectUnitType('goblin')">
                        <svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                            <rect x="-2" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                            <rect x="0.5" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                            <path d="M -2,8 L -0.5,8 L -1.25,10 Z" fill="#7a9a3a"/>
                            <path d="M 0.5,8 L 2,8 L 1.25,10 Z" fill="#7a9a3a"/>
                            <path d="M -3,2 L 3,2 L 0,6 Z" fill="#654321"/>
                            <rect x="-2" y="-4" width="4" height="6" fill="#7a9a3a"/>
                            <ellipse cx="0" cy="-8" rx="3" ry="4" fill="#7a9a3a"/>
                            <path d="M -3,-10 L -2,-8.5 L -5.5,-11 Z" fill="#7a9a3a"/>
                            <path d="M 3,-10 L 2,-8.5 L 5.5,-11 Z" fill="#7a9a3a"/>
                            <path d="M 3,-7 L 2.5,-5.5 L 6,-4 Z" fill="#5a7a2a"/>
                            <path d="M -2,-9.5 L -0.5,-8.5 L -2,-7.5 Z" fill="#ff0000"/>
                            <path d="M 1.5,-9.5 L 0,-8.5 L 1.5,-7.5 Z" fill="#ff0000"/>
                            <line x1="3" y1="0" x2="10" y2="-6" stroke="#4a3520" stroke-width="0.8"/>
                            <path d="M 10,-6 L 11,-8 L 9,-7 Z" fill="#888"/>
                            <line x1="2" y1="0" x2="4" y2="-1" stroke="#7a9a3a" stroke-width="1.2"/>
                        </svg>
                        <span class="unit-name">Goblin Squad</span>
                        <span class="unit-cost">5 üí∞<br>3 units</span>
                    </button>
                    <button id="archerBtn" class="recruit-btn locked" onclick="selectUnitType('archer')">
                        <svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                            <rect x="-2" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                            <rect x="0.5" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                            <path d="M -2,8 L -0.5,8 L -1.25,10 Z" fill="#7a9a3a"/>
                            <path d="M 0.5,8 L 2,8 L 1.25,10 Z" fill="#7a9a3a"/>
                            <path d="M -3,2 L 3,2 L 0,6 Z" fill="#654321"/>
                            <rect x="-3.5" y="-2" width="1.5" height="5" fill="#5a4a2a"/>
                            <rect x="-3.2" y="-2" width="0.4" height="1" fill="#8b4513"/>
                            <rect x="-3.2" y="-0.5" width="0.4" height="1" fill="#8b4513"/>
                            <rect x="-3.2" y="1" width="0.4" height="1" fill="#8b4513"/>
                            <rect x="-2" y="-4" width="4" height="6" fill="#7a9a3a"/>
                            <ellipse cx="0" cy="-8" rx="3" ry="4" fill="#7a9a3a"/>
                            <path d="M -3,-10 L -2,-8.5 L -5.5,-11 Z" fill="#7a9a3a"/>
                            <path d="M 3,-10 L 2,-8.5 L 5.5,-11 Z" fill="#7a9a3a"/>
                            <path d="M 3,-7 L 2.5,-5.5 L 6,-4 Z" fill="#5a7a2a"/>
                            <path d="M -2,-9.5 L -0.5,-8.5 L -2,-7.5 Z" fill="#ff0000"/>
                            <path d="M 1.5,-9.5 L 0,-8.5 L 1.5,-7.5 Z" fill="#ff0000"/>
                            <!-- Curved bow -->
                            <path d="M 3,2 Q 10,-2 11,-7" stroke="#8b4513" stroke-width="1.2" fill="none"/>
                            <!-- Bowstring -->
                            <line x1="3" y1="2" x2="11" y2="-7" stroke="#ffffff" stroke-width="0.5"/>
                            <!-- Arrow -->
                            <line x1="6.5" y1="-2.5" x2="-2" y2="-2" stroke="#8b4513" stroke-width="0.8"/>
                            <path d="M -2,-2 L -3.5,-2.8 L -3.5,-1.2 Z" fill="#888"/>
                            <path d="M 6,-3 L 6.5,-2.5 L 6,-2 Z" fill="#ff6347"/>
                            <line x1="2" y1="0" x2="4" y2="1" stroke="#7a9a3a" stroke-width="1.2"/>
                        </svg>
                        <span class="unit-name">Archer Squad</span>
                        <span class="unit-cost">Requires<br>Fortress</span>
                    </button>
                    <button id="shamanBtn" class="recruit-btn locked" onclick="selectUnitType('shaman')">
                        <svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                            <!-- Long robe -->
                            <path d="M -4,-2 L -5,10 L 5,10 L 4,-2 Z" fill="#1a1a1a"/>
                            <!-- Robe folds -->
                            <path d="M -1,0 L -2,10 L 0,10 Z" fill="#0a0a0a"/>
                            <path d="M 1.5,2 L 2.5,10 L 3.5,10 Z" fill="#0a0a0a"/>
                            <!-- Hood -->
                            <ellipse cx="0" cy="-8" rx="4.5" ry="5" fill="#1a1a1a"/>
                            <!-- Hood shadow -->
                            <path d="M -3.5,-7 A 3.5,3.5 0 0 0 3.5,-7 Z" fill="#0a0a0a"/>
                            <!-- Face in hood -->
                            <ellipse cx="0" cy="-7.5" rx="2.5" ry="3" fill="#7a9a3a"/>
                            <!-- Glowing eyes -->
                            <circle cx="-1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                            <circle cx="1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                            <!-- Staff -->
                            <line x1="3" y1="3" x2="11" y2="-8" stroke="#8b4513" stroke-width="1"/>
                            <!-- Crystal orb -->
                            <circle cx="11" cy="-8" r="1.5" fill="#9370db" opacity="0.8"/>
                            <circle cx="11" cy="-8" r="1" fill="#ba55d3" opacity="0.9"/>
                            <!-- Sparkles -->
                            <circle cx="10" cy="-6" r="0.5" fill="#ffff00" opacity="0.8"/>
                            <circle cx="12.5" cy="-7" r="0.4" fill="#00ffff" opacity="0.8"/>
                            <circle cx="10.5" cy="-9.5" r="0.4" fill="#ff00ff" opacity="0.8"/>
                            <!-- Sleeve -->
                            <path d="M 3,0 L 5,1 L 4,3 L 2,2 Z" fill="#1a1a1a"/>
                        </svg>
                        <span class="unit-name">Shaman Squad</span>
                        <span class="unit-cost">Requires<br>Fortress</span>
                    </button>
                </div>
            </div>

            <!-- Actions -->
            <div class="panel-section">
                <h3 class="panel-title">Actions</h3>
                <div class="action-grid">
                    <button id="upgradeBtn" class="upgrade" onclick="upgradeBuilding()">‚¨ÜÔ∏è Upgrade Building</button>
                    <button id="splitBtn" onclick="splitArmy()">‚úÇÔ∏è Split Army</button>
                    <button id="endTurnBtn" onclick="game.endTurn()">‚è≠Ô∏è End Turn</button>
                </div>
            </div>
        </div>

        <!-- CANVAS -->
        <div id="canvasContainer">
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- RIGHT PANEL: Leaderboard & Info -->
        <div id="rightPanel">
            <!-- Leaderboard -->
            <div class="panel-section">
                <div id="leaderboard">
                    <h3>Factions</h3>
                    <div id="leaderboardContent"></div>
                </div>
            </div>

            <!-- Sun Direction -->
            <div class="panel-section">
                <div id="sunSection">
                    ‚òÄÔ∏è Sun: <span id="sunDirection">East</span>
                </div>
            </div>

            <!-- Building Menu -->
            <div class="panel-section" id="buildingMenuPanel">
                <h3 class="panel-title">Construction</h3>
                <div class="building-grid">
                    <button id="buildFortBtn" class="build-btn" onclick="buildStructure('FORT')">
                        <svg class="building-icon" width="36" height="36" viewBox="-20 -20 40 40" style="display: block; margin: 0 auto;">
                            <!-- Wooden walls following hex edges (6 segments) -->
                            <path d="M 12.1,3.4 L 12.1,7 L 0,14 L 0,10.4
                                     M 0,10.4 L 0,14 L -12.1,7 L -12.1,3.4
                                     M -12.1,3.4 L -12.1,7 L -12.1,-7 L -12.1,-10.4
                                     M -12.1,-10.4 L -12.1,-7 L 0,-14 L 0,-10.4
                                     M 0,-10.4 L 0,-14 L 12.1,-7 L 12.1,-10.4
                                     M 12.1,-10.4 L 12.1,-7 L 12.1,7 L 12.1,3.4"
                                  stroke="#654321" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                            <!-- Tower base -->
                            <rect x="-4" y="-8" width="8" height="11.2" fill="#8B4513"/>
                            <!-- Tower roof (triangular) -->
                            <path d="M -4.8,-8 L 0,-16 L 4.8,-8 Z" fill="#A0522D"/>
                            <!-- Door -->
                            <rect x="-1.2" y="3.2" width="2.4" height="4" fill="#4a2511"/>
                            <!-- Window -->
                            <rect x="-1.6" y="-3.2" width="3.2" height="2.4" fill="#FFA500"/>
                        </svg>
                        <div class="building-info">
                            <span class="building-name">Fort</span>
                            <span class="building-cost">125üí∞</span>
                        </div>
                    </button>
                    <button id="buildTowerBtn" class="build-btn" onclick="buildStructure('TOWER')">
                        <svg class="building-icon" width="36" height="36" viewBox="-20 -20 40 40" style="display: block; margin: 0 auto;">
                            <!-- Stone base platform -->
                            <rect x="-8" y="10" width="16" height="3" fill="#5A5A5A" stroke="#3A3A3A" stroke-width="0.5"/>

                            <!-- Wooden tower structure -->
                            <rect x="-6" y="-2" width="12" height="12" fill="#6B4423" stroke="#4A2511" stroke-width="1"/>

                            <!-- Wooden planks detail -->
                            <line x1="-6" y1="2" x2="6" y2="2" stroke="#4A2511" stroke-width="0.5"/>
                            <line x1="-6" y1="6" x2="6" y2="6" stroke="#4A2511" stroke-width="0.5"/>

                            <!-- Observation platform -->
                            <rect x="-7" y="-4" width="14" height="2" fill="#8B6F47" stroke="#4A2511" stroke-width="0.8"/>

                            <!-- Wooden railings -->
                            <line x1="-7" y1="-3" x2="-7" y2="-8" stroke="#4A2511" stroke-width="1.2"/>
                            <line x1="-3" y1="-3" x2="-3" y2="-8" stroke="#4A2511" stroke-width="1.2"/>
                            <line x1="3" y1="-3" x2="3" y2="-8" stroke="#4A2511" stroke-width="1.2"/>
                            <line x1="7" y1="-3" x2="7" y2="-8" stroke="#4A2511" stroke-width="1.2"/>

                            <!-- Top railing -->
                            <line x1="-7" y1="-8" x2="7" y2="-8" stroke="#4A2511" stroke-width="1.2"/>

                            <!-- Pointed roof -->
                            <path d="M -8,-8 L 0,-16 L 8,-8 Z" fill="#654321" stroke="#4A2511" stroke-width="0.8"/>

                            <!-- Roof texture -->
                            <line x1="-4" y1="-12" x2="-6" y2="-9" stroke="#4A2511" stroke-width="0.5" opacity="0.6"/>
                            <line x1="4" y1="-12" x2="6" y2="-9" stroke="#4A2511" stroke-width="0.5" opacity="0.6"/>

                            <!-- Door -->
                            <rect x="-2" y="6" width="4" height="4" fill="#3A2511" stroke="#2A1511" stroke-width="0.5"/>

                            <!-- Window on platform -->
                            <circle cx="0" cy="-6" r="1.5" fill="#FFA500" opacity="0.8"/>

                            <!-- Support beams -->
                            <line x1="-6" y1="10" x2="-6" y2="-2" stroke="#4A2511" stroke-width="0.8"/>
                            <line x1="6" y1="10" x2="6" y2="-2" stroke="#4A2511" stroke-width="0.8"/>
                        </svg>
                        <div class="building-info">
                            <span class="building-name">Watch<br>Tower</span>
                            <span class="building-cost">75üí∞</span>
                        </div>
                    </button>
                    <button id="buildFarmBtn" class="build-btn" onclick="buildStructure('FARM')">
                        <svg class="building-icon" width="36" height="36" viewBox="-20 -20 40 40" style="display: block; margin: 0 auto;">
                            <!-- Left crop field -->
                            <rect x="-12" y="-6" width="6" height="6" fill="#9ACD32"/>
                            <!-- Left field crop rows -->
                            <line x1="-12" y1="-4" x2="-6" y2="-4" stroke="#6B8E23" stroke-width="0.5"/>
                            <line x1="-12" y1="-2" x2="-6" y2="-2" stroke="#6B8E23" stroke-width="0.5"/>
                            <line x1="-12" y1="0" x2="-6" y2="0" stroke="#6B8E23" stroke-width="0.5"/>

                            <!-- Right crop field -->
                            <rect x="6" y="-6" width="6" height="6" fill="#9ACD32"/>
                            <!-- Right field crop rows -->
                            <line x1="6" y1="-4" x2="12" y2="-4" stroke="#6B8E23" stroke-width="0.5"/>
                            <line x1="6" y1="-2" x2="12" y2="-2" stroke="#6B8E23" stroke-width="0.5"/>
                            <line x1="6" y1="0" x2="12" y2="0" stroke="#6B8E23" stroke-width="0.5"/>

                            <!-- Barn base (red wood) -->
                            <rect x="-5" y="-4.67" width="10" height="8.4" fill="#A0522D"/>

                            <!-- Barn roof (gambrel style) -->
                            <path d="M -6,-4.67 L -4,-9.1 L 0,-11.2 L 4,-9.1 L 6,-4.67 Z" fill="#8B4513"/>

                            <!-- Barn door -->
                            <rect x="-1.5" y="0.7" width="3" height="3.08" fill="#654321"/>

                            <!-- Hay loft window (circular) -->
                            <circle cx="0" cy="-4.2" r="1.2" fill="#4a2511"/>

                            <!-- Left fence posts -->
                            <rect x="-15" y="2" width="0.8" height="5" fill="#654321"/>
                            <rect x="-10" y="2" width="0.8" height="5" fill="#654321"/>

                            <!-- Right fence posts -->
                            <rect x="10" y="2" width="0.8" height="5" fill="#654321"/>
                            <rect x="15" y="2" width="0.8" height="5" fill="#654321"/>

                            <!-- Left fence rail -->
                            <line x1="-15" y1="3" x2="-10" y2="3" stroke="#654321" stroke-width="1"/>

                            <!-- Right fence rail -->
                            <line x1="10" y1="3" x2="15" y2="3" stroke="#654321" stroke-width="1"/>
                        </svg>
                        <div class="building-info">
                            <span class="building-name">Farm</span>
                            <span class="building-cost">100üí∞</span>
                        </div>
                    </button>
                    <button id="buildDockBtn" class="build-btn" onclick="buildStructure('DOCK')">
                        <svg class="building-icon" width="36" height="36" viewBox="-20 -20 40 40" style="display: block; margin: 0 auto;">
                            <!-- Water indication -->
                            <rect x="-20" y="8" width="40" height="12" fill="#4682B4" opacity="0.3"/>

                            <!-- Support posts in water -->
                            <rect x="-12" y="0" width="2" height="16" fill="#654321"/>
                            <rect x="-2" y="0" width="2" height="16" fill="#654321"/>
                            <rect x="8" y="0" width="2" height="16" fill="#654321"/>

                            <!-- Wooden platform/deck -->
                            <rect x="-14" y="-1" width="26" height="3" fill="#8B6F47" stroke="#654321" stroke-width="0.5"/>

                            <!-- Platform planks detail -->
                            <line x1="-10" y1="-1" x2="-10" y2="2" stroke="#654321" stroke-width="0.3"/>
                            <line x1="-5" y1="-1" x2="-5" y2="2" stroke="#654321" stroke-width="0.3"/>
                            <line x1="0" y1="-1" x2="0" y2="2" stroke="#654321" stroke-width="0.3"/>
                            <line x1="5" y1="-1" x2="5" y2="2" stroke="#654321" stroke-width="0.3"/>

                            <!-- Storehouse building -->
                            <rect x="-8" y="-12" width="14" height="11" fill="#A0522D" stroke="#654321" stroke-width="0.8"/>

                            <!-- Storehouse roof -->
                            <path d="M -9,-12 L -1,-17 L 7,-12 Z" fill="#654321"/>

                            <!-- Storehouse door -->
                            <rect x="-2" y="-5" width="3.5" height="4" fill="#4a2511"/>

                            <!-- Storehouse window -->
                            <rect x="2.5" y="-9" width="2.5" height="2.5" fill="#8B7355"/>

                            <!-- Wooden crates on platform -->
                            <rect x="8" y="-3" width="2.5" height="2.5" fill="#654321" opacity="0.7"/>
                            <rect x="10" y="-4" width="2.5" height="2.5" fill="#654321" opacity="0.5"/>
                        </svg>
                        <div class="building-info">
                            <span class="building-name">Dock</span>
                            <span class="building-cost">150üí∞</span>
                        </div>
                    </button>
                </div>
            </div>
        </div>

        <!-- BOTTOM PANEL: Selected Info & Controls -->
        <div id="bottomPanel">
            <div id="selectedInfo">You have 3 goblin squads ready! Merge units by moving them together (max 9 per tile). Right-click to deselect.</div>
            <div id="info">
                <span id="queueInfo"></span>
                Click distant tiles to queue multi-turn paths | Click units again to cancel paths | Press <strong>H</strong> for help
            </div>
        </div>
    </div>
    
    <div id="gameOverlay">
        <div class="overlay-content">
            <h2>DEFEAT</h2>
            <p id="defeatMessage">Your forces have been eliminated!</p>
            <p>All recruitment buildings lost and no units remaining.</p>
            <button onclick="initGame()">New Game</button>
        </div>
    </div>

    <div id="helpOverlay">
        <div class="help-content">
            <h2>HELP GUIDE <span class="close-hint">(Press H to close)</span></h2>
            <div class="help-columns">
                <div class="help-column">
                    <h3>üéÆ Game Mechanics</h3>
                    <div class="help-section">
                        <h4>Objective</h4>
                        <p>Conquer the overworld by defeating all three enemy factions: Ancient, Beast, and Nature.</p>
                    </div>
                    <div class="help-section">
                        <h4>Movement</h4>
                        <p>‚Ä¢ Units can move up to 3 hexes per turn</p>
                        <p>‚Ä¢ Click distant tiles to queue multi-turn movements</p>
                        <p>‚Ä¢ Merge units by moving them together (max 9 per tile)</p>
                    </div>
                    <div class="help-section">
                        <h4>Combat</h4>
                        <p>‚Ä¢ Melee units (Goblins) move adjacent to enemies to attack</p>
                        <p>‚Ä¢ Archers attack from range (2-3 hexes away)</p>
                        <p>‚Ä¢ Shamans weaken enemies but deal no direct damage</p>
                        <p>‚Ä¢ Units gain experience and rank up every 3 victories</p>
                    </div>
                    <div class="help-section">
                        <h4>Buildings</h4>
                        <p>‚Ä¢ <strong>Forts:</strong> Recruit units and provide supply (125g)</p>
                        <p>‚Ä¢ <strong>Farms:</strong> Increase unit capacity (100g)</p>
                        <p>‚Ä¢ <strong>Towers:</strong> Extend vision range (75g)</p>
                        <p>‚Ä¢ <strong>Docks:</strong> Enable naval travel (150g)</p>
                        <p>‚Ä¢ Upgrade your starting camp to a Fortress (30g) to unlock Archers & Shamans</p>
                    </div>
                    <div class="help-section">
                        <h4>Resources</h4>
                        <p>‚Ä¢ Gold mines and buildings generate income each turn</p>
                        <p>‚Ä¢ Supply limit is determined by building bonuses</p>
                    </div>
                    <div class="help-section">
                        <h4>Keyboard Shortcuts</h4>
                        <p>‚Ä¢ <strong>H:</strong> Toggle this help menu</p>
                    </div>
                    <div class="help-section">
                        <h4>Controls</h4>
                        <p>‚Ä¢ <strong>Left Click:</strong> Select units or buildings</p>
                        <p>‚Ä¢ <strong>Left Click (same tile):</strong> Cycle between unit/building selection</p>
                        <p>‚Ä¢ <strong>Left Click (unit again):</strong> Cancel queued movement path</p>
                        <p>‚Ä¢ <strong>Right Click:</strong> Deselect current unit/building</p>
                        <p>‚Ä¢ <strong>Mouse Wheel:</strong> Zoom in/out</p>
                        <p>‚Ä¢ <strong>Left Click + Drag:</strong> Pan the camera</p>
                    </div>
                </div>
                <div class="help-column">
                    <h3>üìñ Story & Guidance</h3>
                    <div class="help-section story">
                        <h4>The Tale of the Banished</h4>
                        <p>You were once proud denizens of the Underworld, dwelling in the eternal darkness beneath the surface. But your tribe committed the unforgivable sin in goblin society: you were caught being <em>too stupid</em>.</p>
                        <p>While other goblins schemed and plotted with cunning malice, your tribe tried to dig through a wall... that was painted on. While others built elaborate traps, you got caught in your own snares. While others hoarded treasure, you traded gold for "magic beans."</p>
                        <p>The Goblin King had enough. In a grand ceremony of mockery and shame, your entire tribe was banished to the Overworld‚Äîthat bright, horrible place with the burning sky-orb and fresh air.</p>
                        <p><strong>"Prove you're not complete idiots,"</strong> the King decreed, <strong>"or never return!"</strong></p>
                    </div>
                    <div class="help-section">
                        <h4>Your Quest for Redemption</h4>
                        <p>Now you must prove your worth by doing what goblins do best: conquering territory through overwhelming numbers and surprisingly effective tactics (when they work).</p>
                        <p>The Overworld is already claimed by three powerful factions:</p>
                        <p>‚Ä¢ <strong>The Ancients</strong> - Stone guardians who think you're barely worth noticing</p>
                        <p>‚Ä¢ <strong>The Beasts</strong> - Wild creatures who see you as annoying pests</p>
                        <p>‚Ä¢ <strong>The Nature Spirits</strong> - Mystical beings offended by your existence</p>
                        <p>Defeat them all, claim the Overworld, and maybe‚Äîjust maybe‚Äîyou'll earn the right to return home with your heads held high (or at least not dragging on the ground).</p>
                    </div>
                    <div class="help-section">
                        <h4>The Horde Strategy</h4>
                        <p><strong>Core Principle:</strong> Numbers win wars! Your goal is to produce endless waves of goblins and overwhelm your enemies through sheer quantity.</p>
                        <p><strong>Station Armies on Buildings:</strong> Always keep units stationed on resource buildings (gold mines, forts) to continuously collect their income. Never leave valuable buildings unguarded!</p>
                        <p><strong>Build When Necessary:</strong> Build Farms when you hit unit cap. Build Forts to produce more units closer to the front lines. Only build what you need to keep the goblin production flowing.</p>
                        <p><strong>Goblin Mass Production:</strong> Spend all your gold on goblin squads! Fill your army to the unit cap, then immediately send waves toward the enemy. When units die, recruit more. The horde never stops!</p>
                        <p><strong>The Endless Wave:</strong> Don't worry about tactics or fancy units. Pure goblin swarm is the way. Three goblins die? Recruit three more. The enemy can't handle infinite goblins!</p>
                        <p><strong>Remember:</strong> You were called stupid, so prove them wrong with the simplest strategy of all‚Äîoverwhelming force! WAAAGH!</p>
                    </div>
                    <div class="help-section">
                        <h4>Remember</h4>
                        <p>You may have been called stupid, but even the dumbest goblin knows that victory through overwhelming numbers is still victory. Now go forth and prove you're only <em>mostly</em> stupid!</p>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px; padding: 15px; border-top: 2px solid rgba(138, 43, 226, 0.4); color: #8a7a65; font-size: 16px;">
                Press <strong style="color: #d4af37;">H</strong> to close
            </div>
        </div>
    </div>

    <div id="welcomeMessage">Turn 1, press H for Help</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        const selectedInfo = document.getElementById('selectedInfo');
        
        // Map configuration
        const HEX_SIZE = 20;
        const MAP_RADIUS = 36;
        const SEA_WIDTH = 12;
        const VOID_WIDTH = 6;
        const TOTAL_RADIUS = MAP_RADIUS + SEA_WIDTH + VOID_WIDTH;
        
        // Calculate map dimensions
        const hexWidth = Math.sqrt(3) * HEX_SIZE;
        const hexHeight = HEX_SIZE * 2;
        const mapWidth = (TOTAL_RADIUS * 2 + 1) * hexWidth + hexWidth * 0.5;
        const mapHeight = (TOTAL_RADIUS * 2 + 1) * hexHeight * 0.75 + hexHeight * 0.25;
        
        // Set canvas to window size
        function resizeCanvas() {
            const canvasContainer = document.getElementById('canvasContainer');
            if (!canvasContainer) {
                console.warn('Canvas container not found, retrying...');
                setTimeout(resizeCanvas, 50);
                return;
            }

            const rect = canvasContainer.getBoundingClientRect();

            // Use the actual available space in the canvas container
            const availableWidth = rect.width - 40; // Subtract some padding
            const availableHeight = rect.height - 40;

            canvas.width = Math.max(400, Math.min(availableWidth, 1800));
            canvas.height = Math.max(400, Math.min(availableHeight, 1200));

            const zoomX = canvas.width / mapWidth;
            const zoomY = canvas.height / mapHeight;
            targetZoom = Math.min(zoomX, zoomY) * 0.85;
            targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom));
            zoom = targetZoom;

            offsetX = 0;
            offsetY = 0;
            targetOffsetX = 0;
            targetOffsetY = 0;

            drawMap();
        }
        
        // Camera/zoom variables
        let zoom = 0.6;
        let targetZoom = 0.6;
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 3;
        const ZOOM_SPEED = 0.1;
        const ZOOM_SMOOTHING = 0.15; // Restored to original
        let offsetX = 0;
        let offsetY = 0;
        let targetOffsetX = 0;
        let targetOffsetY = 0;
        const CAMERA_SMOOTHING = 0.12; // Restored to original
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        
        // Animation variables
        let animationTime = 0;
        let animationFrame = null;
        
        // Water wave animation - waves move from void towards land
        function calculateWaveEffect(hex, time) {
            if (hex.type !== TILE_TYPES.SEA) return 0;

            // Calculate distance from void boundary (outer edge)
            const distFromCenter = hex.distance;
            const distFromVoid = (MAP_RADIUS + SEA_WIDTH) - distFromCenter;

            // Calculate angle around the map for positional variation
            const angle = Math.atan2(hex.r, hex.q);

            // Create segments around the map (smaller segments = more waves)
            // Use angle to create spatial variation
            const segmentSize = 0.1; // 3x more waves
            const segmentPhase1 = Math.sin(angle / segmentSize + time * 0.000225);
            const segmentPhase2 = Math.sin(angle / segmentSize * 1.3 + time * 0.0003375 + 1.5);
            const segmentPhase3 = Math.cos(angle / segmentSize * 0.8 + time * 0.00027 + 3);

            // Only show waves where segment phases are positive (creates individual wave segments)
            const wavePresence = Math.max(0, (segmentPhase1 + segmentPhase2 + segmentPhase3) / 3);

            // Create multiple wave frequencies traveling inward (50% faster than before)
            const waveSpeed1 = 0.000675;  // 50% faster
            const waveSpeed2 = 0.001125;  // 50% faster
            const waveSpeed3 = 0.00045;   // 50% faster

            // Waves travel inward (towards land)
            const wave1 = Math.sin((distFromVoid * 0.5) - (time * waveSpeed1));
            const wave2 = Math.sin((distFromVoid * 0.8) - (time * waveSpeed2));
            const wave3 = Math.cos((distFromVoid * 0.3) - (time * waveSpeed3));

            // Combine waves
            const combinedWave = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);

            // Fade effect based on distance from void
            const fadeFactor = Math.min(1, distFromVoid / 3);

            // Apply wave presence to create segments
            return combinedWave * fadeFactor * wavePresence * 40;
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Tile types
        const TILE_TYPES = {
            VOID: 'void',
            SEA: 'sea',
            LAND: 'land'
        };
        
        // Base colors
        const BASE_COLORS = {
            void: { r: 15, g: 10, b: 25 },
            sea: { r: 20, g: 35, b: 55 },
            land: { r: 45, g: 55, b: 40 }
        };
        
        // Factions
        const FACTIONS = {
            PLAYER: 'player',
            NATURE: 'nature',
            ANCIENT: 'ancient',
            BEAST: 'beast'
        };
        
        // Unit types - these are templates
        const UNIT_TEMPLATES = {
            GOBLIN: { name: 'Goblin', symbol: 'üë∫', faction: FACTIONS.PLAYER, baseHp: 1, baseAttack: 1, cost: { gold: 5 }, costText: '5g' },
            GOBLIN_ARCHER: { name: 'Goblin Archer', symbol: 'üèπ', faction: FACTIONS.PLAYER, baseHp: 1, baseAttack: 1, cost: { gold: 5 }, costText: '5g' },
            GOBLIN_SHAMAN: { name: 'Goblin Shaman', symbol: 'üîÆ', faction: FACTIONS.PLAYER, baseHp: 1, baseAttack: 0, cost: { gold: 8 }, costText: '8g' },
            WOLF: { name: 'Wolf', symbol: 'üê∫', faction: FACTIONS.BEAST, baseHp: 1, baseAttack: 1 },
            BEAR: { name: 'Bear', symbol: 'üêª', faction: FACTIONS.BEAST, baseHp: 1, baseAttack: 1 },
            TREANT: { name: 'Treant', symbol: 'üå≥', faction: FACTIONS.NATURE, baseHp: 1, baseAttack: 1 },
            DEER: { name: 'Deer', symbol: 'ü¶å', faction: FACTIONS.NATURE, baseHp: 1, baseAttack: 1 },
            GOLEM: { name: 'Stone Golem', symbol: 'üóø', faction: FACTIONS.ANCIENT, baseHp: 1, baseAttack: 1 },
            ELEMENTAL: { name: 'Elemental', symbol: 'üå™Ô∏è', faction: FACTIONS.ANCIENT, baseHp: 1, baseAttack: 1 }
        };
        
        // Create a new unit instance with experience tracking
        function createUnit(template) {
            return {
                ...template,
                hp: template.baseHp,
                attack: template.baseAttack,
                experience: 0,
                battlesWon: 0,
                rank: 0
            };
        }
        
        // Legacy UNIT_TYPES for compatibility
        const UNIT_TYPES = {
            GOBLIN: UNIT_TEMPLATES.GOBLIN,
            GOBLIN_ARCHER: UNIT_TEMPLATES.GOBLIN_ARCHER,
            GOBLIN_SHAMAN: UNIT_TEMPLATES.GOBLIN_SHAMAN,
            WOLF: UNIT_TEMPLATES.WOLF,
            BEAR: UNIT_TEMPLATES.BEAR,
            TREANT: UNIT_TEMPLATES.TREANT,
            DEER: UNIT_TEMPLATES.DEER,
            GOLEM: UNIT_TEMPLATES.GOLEM,
            ELEMENTAL: UNIT_TEMPLATES.ELEMENTAL
        };
        
        // Building types
        const BUILDING_TYPES = {
            GOBLIN_FORT: { name: 'Goblin Fort', symbol: 'üèïÔ∏è', faction: FACTIONS.PLAYER, produces: UNIT_TYPES.GOBLIN, production: 3, supplyBonus: 15, baseIncome: { gold: 2 }, upgradeTo: 'GOBLIN_FORTRESS', upgradeCost: { gold: 30 } },
            GOBLIN_FORTRESS: { name: 'Goblin Fortress', symbol: 'üèØ', faction: FACTIONS.PLAYER, produces: UNIT_TYPES.GOBLIN_SHAMAN, production: 1, supplyBonus: 10, baseIncome: { gold: 5 } },
            GOLD_MINE: { name: 'Gold Mine', symbol: '‚õèÔ∏è', resource: 'gold', amount: 3, supplyBonus: 0 },
            FARM: { name: 'Farm', symbol: 'üåæ', supplyBonus: 6, cost: { gold: 100 } },
            ANCIENT_RUIN: { name: 'Ancient Ruin', symbol: 'üèõÔ∏è', faction: FACTIONS.ANCIENT, produces: UNIT_TYPES.GOLEM, production: 3, supplyBonus: 15, baseIncome: { gold: 3 } },
            BEAST_DEN: { name: 'Beast Den', symbol: 'üï≥Ô∏è', faction: FACTIONS.BEAST, produces: UNIT_TYPES.WOLF, production: 3, supplyBonus: 15, baseIncome: { gold: 3 } },
            NATURE_GROVE: { name: 'Nature Grove', symbol: 'üå≤', faction: FACTIONS.NATURE, produces: UNIT_TYPES.TREANT, production: 3, supplyBonus: 15, baseIncome: { gold: 3 } },
            WATCHTOWER: { name: 'Abandoned Tower', symbol: 'üóº', supplyBonus: 4, viewDistance: 8 },
            ABANDONED_CASTLE: { name: 'Abandoned Castle', symbol: 'üè∞', supplyBonus: 8 },
            FORT: { name: 'Fort', symbol: '‚öîÔ∏è', faction: FACTIONS.PLAYER, produces: UNIT_TYPES.GOBLIN, production: 3, supplyBonus: 10, baseIncome: { gold: 1 }, cost: { gold: 125 } },
            TOWER: { name: 'Watchtower', symbol: 'üóº', supplyBonus: 5, cost: { gold: 75 }, viewDistance: 8 },
            DOCK: { name: 'Dock', symbol: '‚öì', supplyBonus: 3, allowsNaval: true, cost: { gold: 150 }, requiresWater: true }
        };
        
        // Game state
        const game = {
            turn: 1,
            resources: {
                gold: 10
            },
            aiResources: {
                [FACTIONS.ANCIENT]: { gold: 10 },
                [FACTIONS.BEAST]: { gold: 10 },
                [FACTIONS.NATURE]: { gold: 10 }
            },
            aiRecruitmentCooldown: {
                [FACTIONS.ANCIENT]: -999,
                [FACTIONS.BEAST]: -999,
                [FACTIONS.NATURE]: -999
            },
            unitLimit: {
                current: 9,
                max: 15
            },
            selectedHex: null,
            playerStartHex: null,
            mode: 'select',
            validMoves: [],
            movedUnits: new Set(),
            selectionMode: 'unit',
            sunAngle: 0,
            footprints: [],
            skulls: [],
            plannedPaths: new Map(),
            hoveredPath: null,
            selectedUnitType: 'goblin',
            landTilesCache: [],
            interestingTilesCache: new Map(),
            gameOver: false,
            showAllPaths: false,
            ships: [],
            wreckedShips: [],
            buildingPlacementMode: false,
            selectedBuildingType: null,
            validBuildLocations: [],
            smokeParticles: [],
            towerSmokeTimers: new Map(),
            initialZooming: true,
            initialZoomStartTime: 0,
            initialZoomDuration: 3000 // 3 seconds
        };
        
        // Map storage
        const hexMap = new Map();
        
        // Game configuration constants
        const MIN_GARRISON_SIZE = 2;
        const OPTIMAL_GARRISON_SIZE = 3;
        const AI_RECRUITMENT_COOLDOWN = 3;
        const AI_RECRUITMENT_BATCH_SIZE = 3;
        
        // Check if player has fortress
        function playerHasFortress() {
            let hasFortress = false;
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER && hex.building === BUILDING_TYPES.GOBLIN_FORTRESS) {
                    hasFortress = true;
                }
            });
            return hasFortress;
        }

        // Update unit button states based on fortress
        function updateUnitButtonStates() {
            const hasFortress = playerHasFortress();
            const goblinBtn = document.getElementById('goblinBtn');
            const archerBtn = document.getElementById('archerBtn');
            const shamanBtn = document.getElementById('shamanBtn');

            // Helper to clear recruitment state classes
            function clearRecruitmentClasses(btn) {
                btn.classList.remove('can-act', 'cannot-act');
            }

            // Helper to check if a unit type can be recruited
            function canRecruitUnit(unitType) {
                const unitCosts = {
                    'goblin': { cost: 5, count: 3, requiresFortress: false },
                    'archer': { cost: 5, count: 3, requiresFortress: true },
                    'shaman': { cost: 8, count: 3, requiresFortress: true }
                };

                const unit = unitCosts[unitType];
                if (!unit) return false;

                // Check fortress requirement
                if (unit.requiresFortress && !hasFortress) return false;

                // Check gold
                const hasGold = game.resources.gold >= unit.cost;

                // Check supply
                let currentUnits = 0;
                let maxSupply = 0;
                hexMap.forEach(hex => {
                    if (hex.owner === FACTIONS.PLAYER) {
                        currentUnits += hex.units.length;
                        if (hex.building && hex.building.supplyBonus) {
                            maxSupply += hex.building.supplyBonus;
                        }
                    }
                });
                const hasSupply = currentUnits + unit.count <= maxSupply;

                // Check if player has a base
                const hasBase = game.playerStartHex && game.playerStartHex.building && game.playerStartHex.owner === FACTIONS.PLAYER;

                // Check if there's space at base or adjacent hexes
                let hasSpace = false;
                if (hasBase) {
                    const placementHexes = getPlacementHexes(game.playerStartHex, unit.count);
                    hasSpace = placementHexes.length > 0;
                }

                return hasGold && hasSupply && hasBase && hasSpace;
            }

            // Update Goblin button
            clearRecruitmentClasses(goblinBtn);
            if (canRecruitUnit('goblin')) {
                goblinBtn.classList.add('can-act');
            } else {
                goblinBtn.classList.add('cannot-act');
            }

            // Update Archer and Shaman buttons
            if (hasFortress) {
                archerBtn.classList.remove('locked');
                archerBtn.innerHTML = `<svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                    <rect x="-2" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                    <rect x="0.5" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                    <path d="M -2,8 L -0.5,8 L -1.25,10 Z" fill="#7a9a3a"/>
                    <path d="M 0.5,8 L 2,8 L 1.25,10 Z" fill="#7a9a3a"/>
                    <path d="M -3,2 L 3,2 L 0,6 Z" fill="#654321"/>
                    <rect x="-3.5" y="-2" width="1.5" height="5" fill="#5a4a2a"/>
                    <rect x="-3.2" y="-2" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-3.2" y="-0.5" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-3.2" y="1" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-2" y="-4" width="4" height="6" fill="#7a9a3a"/>
                    <ellipse cx="0" cy="-8" rx="3" ry="4" fill="#7a9a3a"/>
                    <path d="M -3,-10 L -2,-8.5 L -5.5,-11 Z" fill="#7a9a3a"/>
                    <path d="M 3,-10 L 2,-8.5 L 5.5,-11 Z" fill="#7a9a3a"/>
                    <path d="M 3,-7 L 2.5,-5.5 L 6,-4 Z" fill="#5a7a2a"/>
                    <path d="M -2,-9.5 L -0.5,-8.5 L -2,-7.5 Z" fill="#ff0000"/>
                    <path d="M 1.5,-9.5 L 0,-8.5 L 1.5,-7.5 Z" fill="#ff0000"/>
                    <path d="M 3,2 Q 10,-2 11,-7" stroke="#8b4513" stroke-width="1.2" fill="none"/>
                    <line x1="3" y1="2" x2="11" y2="-7" stroke="#ffffff" stroke-width="0.5"/>
                    <line x1="6.5" y1="-2.5" x2="-2" y2="-2" stroke="#8b4513" stroke-width="0.8"/>
                    <path d="M -2,-2 L -3.5,-2.8 L -3.5,-1.2 Z" fill="#888"/>
                    <path d="M 6,-3 L 6.5,-2.5 L 6,-2 Z" fill="#ff6347"/>
                    <line x1="2" y1="0" x2="4" y2="1" stroke="#7a9a3a" stroke-width="1.2"/>
                </svg><span class="unit-name">Archer Squad</span><span class="unit-cost">5 üí∞<br>3 units</span>`;
                shamanBtn.classList.remove('locked');
                shamanBtn.innerHTML = `<svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                    <path d="M -4,-2 L -5,10 L 5,10 L 4,-2 Z" fill="#1a1a1a"/>
                    <path d="M -1,0 L -2,10 L 0,10 Z" fill="#0a0a0a"/>
                    <path d="M 1.5,2 L 2.5,10 L 3.5,10 Z" fill="#0a0a0a"/>
                    <ellipse cx="0" cy="-8" rx="4.5" ry="5" fill="#1a1a1a"/>
                    <path d="M -3.5,-7 A 3.5,3.5 0 0 0 3.5,-7 Z" fill="#0a0a0a"/>
                    <ellipse cx="0" cy="-7.5" rx="2.5" ry="3" fill="#7a9a3a"/>
                    <circle cx="-1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                    <circle cx="1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                    <line x1="3" y1="3" x2="11" y2="-8" stroke="#8b4513" stroke-width="1"/>
                    <circle cx="11" cy="-8" r="1.5" fill="#9370db" opacity="0.8"/>
                    <circle cx="11" cy="-8" r="1" fill="#ba55d3" opacity="0.9"/>
                    <circle cx="10" cy="-6" r="0.5" fill="#ffff00" opacity="0.8"/>
                    <circle cx="12.5" cy="-7" r="0.4" fill="#00ffff" opacity="0.8"/>
                    <circle cx="10.5" cy="-9.5" r="0.4" fill="#ff00ff" opacity="0.8"/>
                    <path d="M 3,0 L 5,1 L 4,3 L 2,2 Z" fill="#1a1a1a"/>
                </svg><span class="unit-name">Shaman Squad</span><span class="unit-cost">8 üí∞<br>3 units</span>`;

                clearRecruitmentClasses(archerBtn);
                clearRecruitmentClasses(shamanBtn);

                if (canRecruitUnit('archer')) {
                    archerBtn.classList.add('can-act');
                } else {
                    archerBtn.classList.add('cannot-act');
                }

                if (canRecruitUnit('shaman')) {
                    shamanBtn.classList.add('can-act');
                } else {
                    shamanBtn.classList.add('cannot-act');
                }
            } else {
                archerBtn.classList.add('locked');
                archerBtn.innerHTML = `<svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                    <rect x="-2" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                    <rect x="0.5" y="2" width="1.5" height="6" fill="#7a9a3a"/>
                    <path d="M -2,8 L -0.5,8 L -1.25,10 Z" fill="#7a9a3a"/>
                    <path d="M 0.5,8 L 2,8 L 1.25,10 Z" fill="#7a9a3a"/>
                    <path d="M -3,2 L 3,2 L 0,6 Z" fill="#654321"/>
                    <rect x="-3.5" y="-2" width="1.5" height="5" fill="#5a4a2a"/>
                    <rect x="-3.2" y="-2" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-3.2" y="-0.5" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-3.2" y="1" width="0.4" height="1" fill="#8b4513"/>
                    <rect x="-2" y="-4" width="4" height="6" fill="#7a9a3a"/>
                    <ellipse cx="0" cy="-8" rx="3" ry="4" fill="#7a9a3a"/>
                    <path d="M -3,-10 L -2,-8.5 L -5.5,-11 Z" fill="#7a9a3a"/>
                    <path d="M 3,-10 L 2,-8.5 L 5.5,-11 Z" fill="#7a9a3a"/>
                    <path d="M 3,-7 L 2.5,-5.5 L 6,-4 Z" fill="#5a7a2a"/>
                    <path d="M -2,-9.5 L -0.5,-8.5 L -2,-7.5 Z" fill="#ff0000"/>
                    <path d="M 1.5,-9.5 L 0,-8.5 L 1.5,-7.5 Z" fill="#ff0000"/>
                    <path d="M 3,2 Q 10,-2 11,-7" stroke="#8b4513" stroke-width="1.2" fill="none"/>
                    <line x1="3" y1="2" x2="11" y2="-7" stroke="#ffffff" stroke-width="0.5"/>
                    <line x1="6.5" y1="-2.5" x2="-2" y2="-2" stroke="#8b4513" stroke-width="0.8"/>
                    <path d="M -2,-2 L -3.5,-2.8 L -3.5,-1.2 Z" fill="#888"/>
                    <path d="M 6,-3 L 6.5,-2.5 L 6,-2 Z" fill="#ff6347"/>
                    <line x1="2" y1="0" x2="4" y2="1" stroke="#7a9a3a" stroke-width="1.2"/>
                </svg><span class="unit-name">Archer Squad</span><span class="unit-cost">Requires<br>Fortress</span>`;
                shamanBtn.classList.add('locked');
                shamanBtn.innerHTML = `<svg class="unit-icon" width="36" height="36" viewBox="-12 -12 24 24">
                    <path d="M -4,-2 L -5,10 L 5,10 L 4,-2 Z" fill="#1a1a1a"/>
                    <path d="M -1,0 L -2,10 L 0,10 Z" fill="#0a0a0a"/>
                    <path d="M 1.5,2 L 2.5,10 L 3.5,10 Z" fill="#0a0a0a"/>
                    <ellipse cx="0" cy="-8" rx="4.5" ry="5" fill="#1a1a1a"/>
                    <path d="M -3.5,-7 A 3.5,3.5 0 0 0 3.5,-7 Z" fill="#0a0a0a"/>
                    <ellipse cx="0" cy="-7.5" rx="2.5" ry="3" fill="#7a9a3a"/>
                    <circle cx="-1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                    <circle cx="1.2" cy="-8" r="0.6" fill="#ff0000" opacity="0.9"/>
                    <line x1="3" y1="3" x2="11" y2="-8" stroke="#8b4513" stroke-width="1"/>
                    <circle cx="11" cy="-8" r="1.5" fill="#9370db" opacity="0.8"/>
                    <circle cx="11" cy="-8" r="1" fill="#ba55d3" opacity="0.9"/>
                    <circle cx="10" cy="-6" r="0.5" fill="#ffff00" opacity="0.8"/>
                    <circle cx="12.5" cy="-7" r="0.4" fill="#00ffff" opacity="0.8"/>
                    <circle cx="10.5" cy="-9.5" r="0.4" fill="#ff00ff" opacity="0.8"/>
                    <path d="M 3,0 L 5,1 L 4,3 L 2,2 Z" fill="#1a1a1a"/>
                </svg><span class="unit-name">Shaman Squad</span><span class="unit-cost">Requires<br>Fortress</span>`;

                clearRecruitmentClasses(archerBtn);
                clearRecruitmentClasses(shamanBtn);

                // If currently selected unit is locked, switch to goblin
                if (game.selectedUnitType === 'archer' || game.selectedUnitType === 'shaman') {
                    game.selectedUnitType = 'goblin';
                }
            }
        }

        // Upgrade building function
        function upgradeBuilding() {
            if (game.gameOver) return;

            if (!game.selectedHex || game.selectedHex.owner !== FACTIONS.PLAYER) {
                selectedInfo.textContent = 'Select one of your buildings to upgrade.';
                return;
            }

            if (game.selectionMode !== 'building') {
                selectedInfo.textContent = 'Click on the tile again to select the building for upgrade.';
                return;
            }

            const building = game.selectedHex.building;

            if (!building) {
                selectedInfo.textContent = 'This tile has no building to upgrade.';
                return;
            }

            if (!building.upgradeTo) {
                selectedInfo.textContent = `${building.name} cannot be upgraded.`;
                return;
            }

            const upgradeCost = building.upgradeCost.gold;

            if (game.resources.gold < upgradeCost) {
                selectedInfo.textContent = `Upgrade requires ${upgradeCost} gold. You have ${game.resources.gold} gold.`;
                return;
            }

            // Perform upgrade
            game.resources.gold -= upgradeCost;
            const newBuilding = BUILDING_TYPES[building.upgradeTo];
            game.selectedHex.building = newBuilding;

            // Update player start hex if this was the main base
            if (game.playerStartHex && game.playerStartHex.q === game.selectedHex.q && game.playerStartHex.r === game.selectedHex.r) {
                game.playerStartHex = game.selectedHex;
            }

            selectedInfo.textContent = `Upgraded to ${newBuilding.name}! Now produces ${newBuilding.produces.name} units. ${newBuilding.baseIncome.gold}g/turn income.`;
            updateUnitButtonStates();
            updateUI();
            drawMap();
        }
        
        // Check lose condition
        function checkLoseCondition() {
            if (game.gameOver) return;
            
            let hasRecruitmentBuilding = false;
            let hasUnits = false;
            
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER) {
                    // Check for recruitment buildings
                    if (hex.building && hex.building.produces && hex.building.faction === FACTIONS.PLAYER) {
                        hasRecruitmentBuilding = true;
                    }
                    // Check for units
                    if (hex.units.length > 0) {
                        hasUnits = true;
                    }
                }
            });
            
            // Player loses if they have no recruitment buildings AND no units
            if (!hasRecruitmentBuilding && !hasUnits) {
                game.gameOver = true;
                showGameOver();
            }
        }
        
        // Show game over screen
        function showGameOver() {
            const overlay = document.getElementById('gameOverlay');
            const message = document.getElementById('defeatMessage');
            
            let playerUnits = 0;
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER) {
                    playerUnits += hex.units.length;
                }
            });
            
            message.textContent = `Your empire has fallen on turn ${game.turn}!`;
            overlay.classList.add('show');

            // Disable game controls
            document.getElementById('endTurnBtn').disabled = true;
            document.getElementById('splitBtn').disabled = true;
            document.getElementById('upgradeBtn').disabled = true;
        }
        
        // Generate color variation
        function getColorVariation(baseColor, variation = 20) {
            const factor = (Math.random() - 0.5) * 2 * variation;
            const magicTint = Math.random() * 5;
            const r = Math.max(0, Math.min(255, baseColor.r + factor - magicTint));
            const g = Math.max(0, Math.min(255, baseColor.g + factor));
            const b = Math.max(0, Math.min(255, baseColor.b + factor + magicTint));
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        // Naval movement functions
        function embarkShip(fromHex, toHex) {
            // Create ship on water tile
            const ship = {
                q: toHex.q,
                r: toHex.r,
                units: [...fromHex.units],
                owner: fromHex.owner,
                originQ: fromHex.q,
                originR: fromHex.r
            };

            toHex.ship = ship;
            toHex.owner = fromHex.owner;
            game.ships.push(ship);

            fromHex.units = [];
            if (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner) {
                fromHex.owner = null;
            }

            game.movedUnits.add(`${toHex.q},${toHex.r}`);
            return true;
        }

        function moveShip(fromHex, toHex) {
            const distance = getHexDistance(fromHex.q, fromHex.r, toHex.q, toHex.r);
            if (distance > 3) return false;
            if (toHex.type !== TILE_TYPES.SEA) return false;
            if (toHex.ship) return false; // Can't stack ships

            // Move ship
            const ship = fromHex.ship;
            ship.q = toHex.q;
            ship.r = toHex.r;

            toHex.ship = ship;
            toHex.owner = ship.owner;
            fromHex.ship = null;
            fromHex.owner = null;

            game.movedUnits.add(`${toHex.q},${toHex.r}`);
            return true;
        }

        function disembarkShip(fromHex, toHex) {
            const ship = fromHex.ship;

            // Land units on land tile
            toHex.units = [...ship.units];
            toHex.owner = ship.owner;

            // Check if landing at dock
            if (toHex.building && toHex.building.allowsNaval) {
                // Destroy ship at dock
                destroyShip(fromHex);
            } else {
                // Leave broken ship on water
                createWreckedShip(fromHex);
            }

            game.movedUnits.add(`${toHex.q},${toHex.r}`);
            return true;
        }

        function destroyShip(hex) {
            const shipIndex = game.ships.findIndex(s => s.q === hex.q && s.r === hex.r);
            if (shipIndex !== -1) {
                game.ships.splice(shipIndex, 1);
            }
            hex.ship = null;
        }

        function createWreckedShip(hex) {
            destroyShip(hex);

            game.wreckedShips.push({
                q: hex.q,
                r: hex.r,
                createdTurn: game.turn,
                opacity: 1.0
            });
        }

        function processWreckedShips() {
            // Called in game.endTurn()
            game.wreckedShips = game.wreckedShips.filter(wreck => {
                const age = game.turn - wreck.createdTurn;
                if (age >= 3) return false; // Remove after 3 turns

                // Fade opacity
                wreck.opacity = 1.0 - (age / 3);
                return true;
            });
        }

        // Build structure function
        function buildStructure(buildingType) {
            const building = BUILDING_TYPES[buildingType];

            // Check if not enough gold
            if (game.resources.gold < building.cost.gold) {
                selectedInfo.textContent = `Not enough gold! Need ${building.cost.gold} gold.`;
                return;
            }

            // Toggle placement mode
            if (game.buildingPlacementMode && game.selectedBuildingType === buildingType) {
                // Cancel placement mode
                game.buildingPlacementMode = false;
                game.selectedBuildingType = null;
                game.validBuildLocations = [];
                const canvas = document.getElementById('gameCanvas');
                canvas.style.cursor = 'default';
                canvas.classList.remove('cursor-valid', 'cursor-invalid');
                selectedInfo.textContent = 'Building placement cancelled.';
                updateBuildingButtonStates();
                drawMap();
            } else {
                // Enter placement mode
                game.buildingPlacementMode = true;
                game.selectedBuildingType = buildingType;
                selectedInfo.textContent = `Select a location to build ${building.name}. Right-click to cancel.`;
                updateBuildingButtonStates();
                drawMap();
            }
        }

        function canBuildAt(hex, buildingType) {
            const building = BUILDING_TYPES[buildingType];

            // Validation checks
            if (hex.type !== TILE_TYPES.LAND) return false;
            if (hex.building) return false;
            if (hex.owner !== FACTIONS.PLAYER) return false;
            if (hex.units.length === 0) return false;

            // Special check for dock - needs adjacent water
            if (building.requiresWater) {
                const neighbors = getNeighbors(hex.q, hex.r);
                const hasWater = neighbors.some(n => {
                    const neighborHex = hexMap.get(`${n.q},${n.r}`);
                    return neighborHex && neighborHex.type === TILE_TYPES.SEA;
                });
                if (!hasWater) return false;
            }

            return true;
        }

        function placeBuildingAt(hex, buildingType) {
            const building = BUILDING_TYPES[buildingType];

            if (!canBuildAt(hex, buildingType)) {
                selectedInfo.textContent = 'Cannot build here!';
                return false;
            }

            if (game.resources.gold < building.cost.gold) {
                selectedInfo.textContent = `Not enough gold! Need ${building.cost.gold} gold.`;
                return false;
            }

            // Build the structure
            game.resources.gold -= building.cost.gold;
            hex.building = building;

            // Exit placement mode
            game.buildingPlacementMode = false;
            game.selectedBuildingType = null;
            game.validBuildLocations = [];
            const canvas = document.getElementById('gameCanvas');
            canvas.style.cursor = 'default';
            canvas.classList.remove('cursor-valid', 'cursor-invalid');

            selectedInfo.textContent = `${building.name} constructed! +${building.supplyBonus} supply limit.`;

            updateBuildingButtonStates();
            updateUI();
            drawMap();
            return true;
        }

        function updateBuildingButtonStates() {
            const buttons = ['buildFortBtn', 'buildTowerBtn', 'buildFarmBtn', 'buildDockBtn'];
            const types = ['FORT', 'TOWER', 'FARM', 'DOCK'];

            buttons.forEach((btnId, index) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    if (game.buildingPlacementMode && game.selectedBuildingType === types[index]) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        // Smoke particle system for towers
        function checkTowerHasEnemiesInView(towerHex) {
            if (!towerHex.building || !towerHex.building.viewDistance) {
                return false;
            }

            // Check if tower has units on it
            if (!towerHex.units || towerHex.units.length === 0) {
                return false;
            }

            const towerOwner = towerHex.owner;
            if (!towerOwner) return false;

            const viewDistance = towerHex.building.viewDistance;

            // Check all hexes within view distance for enemies
            let hasEnemies = false;
            hexMap.forEach(hex => {
                const distance = getHexDistance(towerHex.q, towerHex.r, hex.q, hex.r);
                if (distance <= viewDistance && hex.units.length > 0 && hex.owner && hex.owner !== towerOwner) {
                    hasEnemies = true;
                }
            });

            return hasEnemies;
        }

        function spawnSmokeParticle(q, r) {
            // Store world coordinates instead of screen coordinates
            const worldX = HEX_SIZE * Math.sqrt(3) * (q + r/2);
            const worldY = HEX_SIZE * (3/2 * r);

            const particle = {
                worldX: worldX + (Math.random() - 0.5) * HEX_SIZE * 0.3,
                worldY: worldY - HEX_SIZE * 0.8,
                vx: (Math.random() - 0.5) * 0.3,
                vy: -0.6 - Math.random() * 0.3,
                size: 2 + Math.random() * 2,
                opacity: 0.4 + Math.random() * 0.2,
                life: 0,
                maxLife: 50 + Math.random() * 30
            };
            game.smokeParticles.push(particle);
        }

        function updateAndDrawSmokeParticles() {
            for (let i = game.smokeParticles.length - 1; i >= 0; i--) {
                const particle = game.smokeParticles[i];

                // Update particle in world space
                particle.worldX += particle.vx;
                particle.worldY += particle.vy;
                particle.life++;
                particle.size += 0.05;

                // Fade out as life progresses
                const lifeRatio = particle.life / particle.maxLife;
                const currentOpacity = particle.opacity * (1 - lifeRatio);

                // Remove dead particles
                if (particle.life >= particle.maxLife) {
                    game.smokeParticles.splice(i, 1);
                    continue;
                }

                // Convert world coordinates to screen coordinates for rendering
                const screenX = (particle.worldX * zoom) + offsetX + canvas.width / 2;
                const screenY = (particle.worldY * zoom) + offsetY + canvas.height / 2;

                // Draw particle (size scales with zoom)
                ctx.save();
                ctx.globalAlpha = currentOpacity;
                ctx.fillStyle = `rgb(${100 + lifeRatio * 100}, ${100 + lifeRatio * 100}, ${100 + lifeRatio * 100})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, particle.size * zoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function updateTowerSmoke() {
            // Check only player-built towers (not abandoned) with units and spawn smoke if enemies in view
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER && hex.building && hex.building.viewDistance && hex.units.length > 0 && hex.building.name !== 'Abandoned Tower') {
                    const hexKey = `${hex.q},${hex.r}`;

                    if (checkTowerHasEnemiesInView(hex)) {
                        // Initialize timer for this tower if not exists
                        if (!game.towerSmokeTimers.has(hexKey)) {
                            game.towerSmokeTimers.set(hexKey, 0);
                        }

                        // Increment timer
                        const timer = game.towerSmokeTimers.get(hexKey) + 1;
                        game.towerSmokeTimers.set(hexKey, timer);

                        // Spawn 1 smoke per second (60 frames)
                        if (timer >= 60) {
                            spawnSmokeParticle(hex.q, hex.r);
                            game.towerSmokeTimers.set(hexKey, 0);
                        }
                    } else {
                        // Reset timer if no enemies in view
                        game.towerSmokeTimers.delete(hexKey);
                    }
                }
            });
        }

        // Calculate sun lighting
        function calculateSunLight(q, r) {
            const worldX = HEX_SIZE * Math.sqrt(3) * (q + r/2);
            const worldY = HEX_SIZE * (3/2 * r);
            const hexAngle = Math.atan2(worldY, worldX);
            
            let angleDiff = hexAngle - game.sunAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            let lightValue = 0;
            if (Math.abs(angleDiff) < Math.PI / 2) {
                lightValue = Math.cos(angleDiff);
                lightValue = Math.pow(lightValue, 0.7);
            } else {
                const darkAngle = Math.abs(angleDiff) - Math.PI / 2;
                lightValue = 0.15 * (1 - darkAngle / (Math.PI / 2));
            }
            
            const terminalDistance = Math.abs(Math.abs(angleDiff) - Math.PI / 2);
            if (terminalDistance < Math.PI / 6) {
                const twilightGlow = (1 - terminalDistance / (Math.PI / 6)) * 0.3;
                lightValue += twilightGlow * 0.5;
            }
            
            const hexDist = hexDistance(q, r);
            const fogFactor = 1 - (hexDist / TOTAL_RADIUS) * 0.3;
            
            return Math.max(0.1, Math.min(1, lightValue * fogFactor));
        }

        // Calculate godray effect - slow moving patches of light
        function calculateGodrayEffect(q, r, time) {
            // Faster time scaling for more dynamic movement
            const slowTime = time * 0.0008;

            // Create multiple overlapping patches at different scales
            // Large patches - slow moving
            const largeWave1 = Math.sin(q * 0.2 + r * 0.15 + slowTime);
            const largeWave2 = Math.cos(q * 0.18 - r * 0.22 + slowTime * 0.7);

            // Medium patches - slightly faster
            const mediumWave1 = Math.sin(q * 0.35 + r * 0.3 + slowTime * 1.5);
            const mediumWave2 = Math.cos(q * 0.28 - r * 0.38 + slowTime * 1.3);

            // Small patches for detail
            const smallWave = Math.sin(q * 0.5 + r * 0.45 + slowTime * 2);

            // Combine waves with different weights
            const combined = (largeWave1 * 0.4 + largeWave2 * 0.3 +
                            mediumWave1 * 0.2 + mediumWave2 * 0.15 +
                            smallWave * 0.1);

            // Convert to 0-1 range and apply softening curve
            const normalized = (combined + 1.3) / 2.6;
            const softened = Math.pow(Math.max(0, normalized), 1.8);

            // Return brightness multiplier (0.7 to 1.3 range for subtle effect)
            return 0.7 + softened * 0.6;
        }

        // Apply lighting
        function applyLighting(color, lightValue) {
            const rgb = color.match(/\d+/g);
            const r = parseInt(rgb[0]);
            const g = parseInt(rgb[1]);
            const b = parseInt(rgb[2]);
            
            const shadowR = r * 0.4 + 5;
            const shadowG = g * 0.4 + 3;
            const shadowB = b * 0.6 + 10;
            
            const sunlightIntensity = Math.pow(lightValue, 0.8);
            const lightR = Math.min(255, r * (1.2 + sunlightIntensity * 0.3) + sunlightIntensity * 25);
            const lightG = Math.min(255, g * (1.1 + sunlightIntensity * 0.2) + sunlightIntensity * 15);
            const lightB = Math.min(255, b * (0.95 + sunlightIntensity * 0.1));
            
            const colorNoise = Math.sin(r + g) * 3;
            
            const gamma = 2.2;
            const invGamma = 1 / gamma;
            
            const shadowRLinear = Math.pow(shadowR / 255, gamma);
            const shadowGLinear = Math.pow(shadowG / 255, gamma);
            const shadowBLinear = Math.pow(shadowB / 255, gamma);
            
            const lightRLinear = Math.pow(lightR / 255, gamma);
            const lightGLinear = Math.pow(lightG / 255, gamma);
            const lightBLinear = Math.pow(lightB / 255, gamma);
            
            const finalRLinear = shadowRLinear + (lightRLinear - shadowRLinear) * lightValue;
            const finalGLinear = shadowGLinear + (lightGLinear - shadowGLinear) * lightValue;
            const finalBLinear = shadowBLinear + (lightBLinear - shadowBLinear) * lightValue;
            
            const finalR = Math.floor(Math.pow(finalRLinear, invGamma) * 255 + colorNoise);
            const finalG = Math.floor(Math.pow(finalGLinear, invGamma) * 255);
            const finalB = Math.floor(Math.pow(finalBLinear, invGamma) * 255 - colorNoise);
            
            const clampedR = Math.max(0, Math.min(255, finalR));
            const clampedG = Math.max(0, Math.min(255, finalG));
            const clampedB = Math.max(0, Math.min(255, finalB));
            
            return `rgb(${clampedR}, ${clampedG}, ${clampedB})`;
        }
        
        // Convert axial to pixel coordinates
        function hexToPixel(q, r) {
            const worldX = HEX_SIZE * Math.sqrt(3) * (q + r/2);
            const worldY = HEX_SIZE * (3/2 * r);
            
            const x = (worldX * zoom) + offsetX + canvas.width / 2;
            const y = (worldY * zoom) + offsetY + canvas.height / 2;
            return { x, y };
        }
        
        // Convert pixel to axial coordinates
        function pixelToHex(x, y) {
            const worldX = (x - canvas.width / 2 - offsetX) / zoom;
            const worldY = (y - canvas.height / 2 - offsetY) / zoom;
            
            const q = (Math.sqrt(3)/3 * worldX - 1/3 * worldY) / HEX_SIZE;
            const r = (2/3 * worldY) / HEX_SIZE;
            
            return axialRound(q, r);
        }
        
        // Round axial coordinates
        function axialRound(q, r) {
            const s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            
            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }
            
            return { q: rq, r: rr };
        }
        
        // Get distance from center
        function hexDistance(q, r) {
            return (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
        }
        
        // Get distance between two hexes
        function getHexDistance(q1, r1, q2, r2) {
            return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
        }
        
        // Hex path cache for performance
        const hexPathCache = new Map();
        let lastCachedZoom = -1;

        function getHexPath(size) {
            const scaledSize = size * zoom * 1.01;

            // Regenerate cache if zoom changed significantly (more than 1%)
            if (Math.abs(zoom - lastCachedZoom) > 0.01) {
                hexPathCache.clear();
                lastCachedZoom = zoom;
            }

            const cacheKey = scaledSize.toFixed(2);

            if (!hexPathCache.has(cacheKey)) {
                const path = new Path2D();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + Math.PI / 6;
                    const hx = scaledSize * Math.cos(angle);
                    const hy = scaledSize * Math.sin(angle);
                    if (i === 0) {
                        path.moveTo(hx, hy);
                    } else {
                        path.lineTo(hx, hy);
                    }
                }
                path.closePath();
                hexPathCache.set(cacheKey, path);
            }

            return hexPathCache.get(cacheKey);
        }

        // Draw hexagon using cached path
        function drawHex(x, y, size, fillColor) {
            const hexPath = getHexPath(size);

            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = fillColor;
            ctx.fill(hexPath);
            ctx.restore();
        }

        // Draw hex outline using cached path
        function strokeHex(x, y, size, strokeColor, lineWidth) {
            const hexPath = getHexPath(size);

            ctx.save();
            ctx.translate(x, y);
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke(hexPath);
            ctx.restore();
        }

        // Fill hex using cached path (without save/restore for performance)
        function fillHexPath(x, y, size, fillColor) {
            const hexPath = getHexPath(size);

            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = fillColor;
            ctx.fill(hexPath);
            ctx.restore();
        }
        
        // Draw selection indicator
        function drawSelectionIndicator(pos, hexSize, isSelected = false) {
            const scaledSize = hexSize * zoom * 1.15;
            const bracketLength = scaledSize * 0.3;
            const bracketThickness = 3 * zoom;
            const pulseAmount = Math.sin(animationTime * 0.003) * 0.05 + 1;
            
            ctx.save();

            if (isSelected) {
                ctx.strokeStyle = '#FFD700';
            }

            ctx.lineWidth = bracketThickness;
            ctx.lineCap = 'round';
            
            const corners = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + Math.PI / 6;
                corners.push({
                    x: pos.x + scaledSize * Math.cos(angle) * pulseAmount,
                    y: pos.y + scaledSize * Math.sin(angle) * pulseAmount
                });
            }
            
            for (let i = 0; i < 6; i++) {
                const corner = corners[i];
                const prevAngle = (Math.PI / 3) * (i - 1) + Math.PI / 6;
                const nextAngle = (Math.PI / 3) * (i + 1) + Math.PI / 6;
                
                ctx.beginPath();
                
                const prevX = corner.x - bracketLength * Math.cos(prevAngle);
                const prevY = corner.y - bracketLength * Math.sin(prevAngle);
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(corner.x, corner.y);
                
                const nextX = corner.x - bracketLength * Math.cos(nextAngle);
                const nextY = corner.y - bracketLength * Math.sin(nextAngle);
                ctx.lineTo(nextX, nextY);
                
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Draw movement indicators
        function drawMoveIndicator(pos, hexSize, moveType) {
            const scaledSize = hexSize * zoom;
            const pulseAmount = Math.sin(animationTime * 0.004) * 0.1 + 0.9;
            
            ctx.save();
            
            let color, glowColor;
            switch(moveType) {
                case 'move':
                    color = 'rgba(68, 255, 68, 0.3)';
                    glowColor = '#44FF44';
                    break;
                case 'attack':
                    color = 'rgba(255, 68, 68, 0.3)';
                    glowColor = '#FF4444';
                    break;
                case 'merge':
                    color = 'rgba(68, 255, 255, 0.3)';
                    glowColor = '#44FFFF';
                    break;
                case 'ranged':
                    color = 'rgba(255, 165, 0, 0.3)';
                    glowColor = '#FFA500';
                    break;
                case 'embark':
                    color = 'rgba(68, 136, 255, 0.3)';
                    glowColor = '#4488FF';
                    break;
                case 'disembark':
                    color = 'rgba(136, 204, 255, 0.3)';
                    glowColor = '#88CCFF';
                    break;
            }
            
            ctx.fillStyle = color;

            // Use cached hex path with pulse scaling
            const hexPath = getHexPath(hexSize);
            ctx.translate(pos.x, pos.y);
            ctx.scale(pulseAmount, pulseAmount);
            ctx.fill(hexPath);

            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 2 * zoom;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Get neighboring hexes
        function getNeighbors(q, r) {
            return [
                { q: q + 1, r: r },
                { q: q + 1, r: r - 1 },
                { q: q, r: r - 1 },
                { q: q - 1, r: r },
                { q: q - 1, r: r + 1 },
                { q: q, r: r + 1 }
            ];
        }
        
        // A* Pathfinding algorithm
        function findPath(startHex, endHex, maxStepsPerTurn = 3) {
            if (endHex.type !== TILE_TYPES.LAND) return null;
            if (startHex.q === endHex.q && startHex.r === endHex.r) return [];
            
            const directDistance = getHexDistance(startHex.q, startHex.r, endHex.q, endHex.r);
            if (directDistance <= maxStepsPerTurn) {
                return [{ hex: endHex, turn: 1 }];
            }
            
            const openSet = new Map();
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            const startKey = `${startHex.q},${startHex.r}`;
            openSet.set(startKey, startHex);
            gScore.set(startKey, 0);
            fScore.set(startKey, getHexDistance(startHex.q, startHex.r, endHex.q, endHex.r));
            
            while (openSet.size > 0) {
                let currentKey = null;
                let lowestFScore = Infinity;
                openSet.forEach((hex, key) => {
                    const score = fScore.get(key);
                    if (score < lowestFScore) {
                        lowestFScore = score;
                        currentKey = key;
                    }
                });
                
                if (!currentKey) break;
                
                const currentHex = openSet.get(currentKey);
                openSet.delete(currentKey);
                
                if (currentHex.q === endHex.q && currentHex.r === endHex.r) {
                    const path = [];
                    let current = currentKey;
                    while (cameFrom.has(current)) {
                        const hex = hexMap.get(current);
                        if (hex) path.unshift(hex);
                        current = cameFrom.get(current);
                    }
                    
                    const turnPath = [];
                    for (let i = 0; i < path.length; i += maxStepsPerTurn) {
                        const turnNumber = Math.floor(i / maxStepsPerTurn) + 1;
                        const endIdx = Math.min(i + maxStepsPerTurn - 1, path.length - 1);
                        turnPath.push({
                            hex: path[endIdx],
                            turn: turnNumber,
                            steps: path.slice(i, endIdx + 1)
                        });
                    }
                    
                    return turnPath;
                }
                
                closedSet.add(currentKey);
                
                const neighbors = getNeighbors(currentHex.q, currentHex.r);
                for (let neighbor of neighbors) {
                    const neighborKey = `${neighbor.q},${neighbor.r}`;
                    const neighborHex = hexMap.get(neighborKey);
                    
                    if (!neighborHex || neighborHex.type !== TILE_TYPES.LAND || closedSet.has(neighborKey)) {
                        continue;
                    }
                    
                    const tentativeGScore = gScore.get(currentKey) + 1;
                    
                    if (!openSet.has(neighborKey)) {
                        openSet.set(neighborKey, neighborHex);
                    } else if (tentativeGScore >= gScore.get(neighborKey)) {
                        continue;
                    }
                    
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeGScore);
                    fScore.set(neighborKey, tentativeGScore + getHexDistance(neighborHex.q, neighborHex.r, endHex.q, endHex.r));
                }
            }
            
            return null;
        }
        
        // Execute planned movements
        function executeAutoMovements() {
            const pathsToProcess = [];
            
            // Collect all paths to process
            game.plannedPaths.forEach((path, hexKey) => {
                pathsToProcess.push({ hexKey, path: [...path] }); // Clone path
            });
            
            // Clear old paths
            game.plannedPaths.clear();
            
            // Process each queued movement
            pathsToProcess.forEach(({ hexKey, path }) => {
                if (path.length === 0) return;
                
                const hex = hexMap.get(hexKey);
                
                // Check if hex still has player units
                if (!hex || hex.units.length === 0 || hex.owner !== FACTIONS.PLAYER) {
                    return;
                }
                
                // Check if already moved this turn
                if (game.movedUnits.has(hexKey)) {
                    // Keep the path for next turn
                    game.plannedPaths.set(hexKey, path);
                    return;
                }
                
                // Check if we're already at the current waypoint - if so, remove it
                while (path.length > 0) {
                    const currentWaypoint = path[0];
                    if (hex.q === currentWaypoint.hex.q && hex.r === currentWaypoint.hex.r) {
                        path.shift(); // Remove waypoint we're already at
                    } else {
                        break; // Not at this waypoint, stop checking
                    }
                }
                
                // If no waypoints left after cleanup, we're done
                if (path.length === 0) return;
                
                // Get next waypoint
                const nextWaypoint = path[0];
                const targetHex = nextWaypoint.hex;
                const directDistance = getHexDistance(hex.q, hex.r, targetHex.q, targetHex.r);
                
                // If target is within movement range (3 hexes), move directly
                if (directDistance <= 3 && directDistance > 0) {
                    const success = moveUnits(hex, targetHex);
                    
                    if (success) {
                        const newKey = `${targetHex.q},${targetHex.r}`;
                        game.movedUnits.add(newKey);
                        
                        // Remove the completed waypoint
                        path.shift();
                        
                        // If more waypoints remain, keep the path
                        if (path.length > 0) {
                            game.plannedPaths.set(newKey, path);
                        }
                    } else {
                        // Movement failed, keep path for retry
                        game.plannedPaths.set(hexKey, path);
                    }
                } else if (directDistance > 3) {
                    // Target is far, find best adjacent hex toward target
                    let bestMove = null;
                    let bestDistance = Infinity;
                    
                    const neighbors = getNeighbors(hex.q, hex.r);
                    for (let n of neighbors) {
                        const neighborHex = hexMap.get(`${n.q},${n.r}`);
                        if (!neighborHex || neighborHex.type !== TILE_TYPES.LAND) continue;
                        
                        // Check if we can move here
                        const canMove = neighborHex.units.length === 0 || 
                                       (neighborHex.owner === FACTIONS.PLAYER && 
                                        neighborHex.units.length + hex.units.length <= 9);
                        
                        if (!canMove) continue;
                        
                        const distToTarget = getHexDistance(n.q, n.r, targetHex.q, targetHex.r);
                        
                        // Pick move that gets us closer
                        if (distToTarget < bestDistance && distToTarget < directDistance) {
                            bestDistance = distToTarget;
                            bestMove = neighborHex;
                        }
                    }
                    
                    if (bestMove) {
                        const success = moveUnits(hex, bestMove);
                        
                        if (success) {
                            const newKey = `${bestMove.q},${bestMove.r}`;
                            game.movedUnits.add(newKey);
                            
                            // Keep the full path
                            game.plannedPaths.set(newKey, path);
                        } else {
                            // Movement blocked, keep path for next turn
                            game.plannedPaths.set(hexKey, path);
                        }
                    } else {
                        // No valid move found, keep path for next turn
                        game.plannedPaths.set(hexKey, path);
                    }
                }
            });
            
            drawMap();
        }
        
        // Generate map
        function generateMap() {
            hexMap.clear();
            
            const noiseMap = new Map();
            for (let q = -TOTAL_RADIUS; q <= TOTAL_RADIUS; q++) {
                for (let r = -TOTAL_RADIUS; r <= TOTAL_RADIUS; r++) {
                    const key = `${q},${r}`;
                    noiseMap.set(key, {
                        primary: Math.random() * 6 - 3,
                        secondary: Math.random() * 4 - 2,
                        tertiary: Math.random() * 3 - 1.5,
                        wave: Math.sin((q + r) * 0.3) * 2,
                        island: Math.random()
                    });
                }
            }
            
            for (let q = -TOTAL_RADIUS; q <= TOTAL_RADIUS; q++) {
                for (let r = -TOTAL_RADIUS; r <= TOTAL_RADIUS; r++) {
                    const s = -q - r;
                    if (Math.abs(s) <= TOTAL_RADIUS) {
                        const distance = hexDistance(q, r);
                        const key = `${q},${r}`;
                        const noise = noiseMap.get(key);
                        
                        let adjustedDistance = distance;
                        
                        if (distance >= MAP_RADIUS - 7 && distance <= MAP_RADIUS + 7) {
                            let smoothedNoise = noise.primary;
                            let neighborCount = 1;
                            
                            getNeighbors(q, r).forEach(n => {
                                const nKey = `${n.q},${n.r}`;
                                if (noiseMap.has(nKey)) {
                                    smoothedNoise += noiseMap.get(nKey).primary * 0.5;
                                    neighborCount += 0.5;
                                }
                            });
                            smoothedNoise /= neighborCount;
                            
                            adjustedDistance = distance + smoothedNoise + noise.secondary * 0.7 + 
                                             noise.tertiary * 0.4 + noise.wave * 0.5;
                            
                            if (distance >= MAP_RADIUS - 3 && distance <= MAP_RADIUS + 3) {
                                if (noise.island > 0.6) {
                                    adjustedDistance += (noise.island > 0.8 ? 5 : -5);
                                }
                            }
                            
                            if (distance >= MAP_RADIUS - 2 && distance <= MAP_RADIUS + 2) {
                                if (noise.island > 0.93) {
                                    adjustedDistance += (noise.island > 0.97 ? 8 : -8);
                                }
                            }
                        }
                        
                        let tileType, baseColor;
                        if (adjustedDistance <= MAP_RADIUS) {
                            tileType = TILE_TYPES.LAND;
                            baseColor = BASE_COLORS.land;
                        } else if (distance <= MAP_RADIUS + SEA_WIDTH) {
                            tileType = TILE_TYPES.SEA;
                            baseColor = BASE_COLORS.sea;
                        } else {
                            tileType = TILE_TYPES.VOID;
                            baseColor = BASE_COLORS.void;
                        }
                        
                        const color = getColorVariation(baseColor);
                        
                        hexMap.set(`${q},${r}`, {
                            q, r, s,
                            type: tileType,
                            distance: distance,
                            adjustedDistance: adjustedDistance,
                            color: color,
                            units: [],
                            building: null,
                            owner: null
                        });
                    }
                }
            }
            
            let updates = [];
            let iterationCount = 0;
            const maxIterations = 3;
            
            while (iterationCount < maxIterations) {
                updates = [];
                hexMap.forEach((hex, key) => {
                    if (hex.type === TILE_TYPES.VOID || hex.distance < 3 || hex.distance > TOTAL_RADIUS - 3) {
                        return;
                    }
                    
                    const neighbors = getNeighbors(hex.q, hex.r);
                    let sameTypeCount = 0;
                    let typeCounts = { land: 0, sea: 0, void: 0 };
                    
                    neighbors.forEach(n => {
                        const neighborKey = `${n.q},${n.r}`;
                        if (hexMap.has(neighborKey)) {
                            const neighbor = hexMap.get(neighborKey);
                            typeCounts[neighbor.type]++;
                            if (neighbor.type === hex.type) sameTypeCount++;
                        }
                    });
                    
                    if (sameTypeCount < 2) {
                        let dominantType = hex.type;
                        let maxCount = sameTypeCount;
                        
                        Object.entries(typeCounts).forEach(([type, count]) => {
                            if (count > maxCount) {
                                maxCount = count;
                                dominantType = type;
                            }
                        });
                        
                        if (dominantType !== hex.type) {
                            let baseColor;
                            if (dominantType === TILE_TYPES.LAND) baseColor = BASE_COLORS.land;
                            else if (dominantType === TILE_TYPES.SEA) baseColor = BASE_COLORS.sea;
                            else baseColor = BASE_COLORS.void;
                            
                            updates.push({
                                key: key,
                                type: dominantType,
                                color: getColorVariation(baseColor)
                            });
                        }
                    }
                });
                
                updates.forEach(update => {
                    const hex = hexMap.get(update.key);
                    hex.type = update.type;
                    hex.color = update.color;
                });
                
                iterationCount++;
                if (updates.length === 0) break;
            }
            
            placeInitialObjects();
            buildPerformanceCaches();
        }
        
        // Build performance caches
        function buildPerformanceCaches() {
            game.landTilesCache = [];
            
            hexMap.forEach(hex => {
                if (hex.type === TILE_TYPES.LAND) {
                    game.landTilesCache.push(hex);
                }
            });
        }
        
        // Build interesting tiles cache for AI
        function buildInterestingTilesCache() {
            [FACTIONS.ANCIENT, FACTIONS.BEAST, FACTIONS.NATURE].forEach(faction => {
                const interestingTiles = [];
                
                game.landTilesCache.forEach(hex => {
                    if (hex.owner === faction) return;
                    
                    if (hex.owner && hex.owner !== faction && hex.units.length > 0) {
                        interestingTiles.push({ hex, type: 'enemy', priority: 1000 });
                    }
                    else if (hex.building && hex.building.faction && hex.building.faction !== faction && hex.owner !== faction) {
                        interestingTiles.push({ hex, type: 'enemy_building', priority: 900 });
                    }
                    else if (hex.building && !hex.owner) {
                        let priority = 500;
                        if (hex.building.resource === 'gold') priority = 700;
                        if (hex.building.supplyBonus >= 6) priority = 650;
                        if (hex.building.supplyBonus > 0) priority = 600;
                        interestingTiles.push({ hex, type: 'neutral_building', priority });
                    }
                });
                
                interestingTiles.sort((a, b) => b.priority - a.priority);
                game.interestingTilesCache.set(faction, interestingTiles);
            });
        }
        
        // Place initial objects
        function placeInitialObjects() {
            const landTiles = [];
            hexMap.forEach(hex => {
                if (hex.type === TILE_TYPES.LAND) {
                    landTiles.push(hex);
                }
            });
            
            if (landTiles.length === 0) return;
            
            const centerLandTiles = landTiles.filter(hex => hex.distance < 10);
            if (centerLandTiles.length > 0) {
                const playerStart = centerLandTiles[Math.floor(Math.random() * centerLandTiles.length)];
                playerStart.building = BUILDING_TYPES.GOBLIN_FORT;
                playerStart.owner = FACTIONS.PLAYER;
                playerStart.units = [createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN)];
                playerStart.unitOrigins = [{ q: playerStart.q, r: playerStart.r, turn: 0 }];
                game.playerStartHex = playerStart;
                
                const neighbors = getNeighbors(playerStart.q, playerStart.r);
                let groupsPlaced = 0;
                
                for (let neighbor of neighbors) {
                    if (groupsPlaced >= 2) break;
                    
                    const key = `${neighbor.q},${neighbor.r}`;
                    const hex = hexMap.get(key);
                    
                    if (hex && hex.type === TILE_TYPES.LAND && !hex.building && hex.units.length === 0) {
                        hex.units = [createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN)];
                        hex.owner = FACTIONS.PLAYER;
                        hex.unitOrigins = [{ q: playerStart.q, r: playerStart.r, turn: 0 }];
                        groupsPlaced++;
                    }
                }
                
                if (groupsPlaced < 2) {
                    hexMap.forEach(hex => {
                        if (groupsPlaced >= 2) return;
                        
                        const distance = getHexDistance(playerStart.q, playerStart.r, hex.q, hex.r);
                        if (distance === 2 && hex.type === TILE_TYPES.LAND && !hex.building && hex.units.length === 0) {
                            hex.units = [createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN), createUnit(UNIT_TYPES.GOBLIN)];
                            hex.owner = FACTIONS.PLAYER;
                            hex.unitOrigins = [{ q: playerStart.q, r: playerStart.r, turn: 0 }];
                            groupsPlaced++;
                        }
                    });
                }
            }
            
            // Helper function to spawn units with variant chance
            const spawnFactionUnits = (baseType, variantType) => {
                const units = [];
                for (let i = 0; i < 3; i++) {
                    units.push(createUnit(Math.random() < 0.3 ? variantType : baseType));
                }
                return units;
            };

            const ancientStartTiles = landTiles.filter(hex => hex.distance > 10 && hex.distance < 25 && !hex.building);
            if (ancientStartTiles.length > 0) {
                const ancientStart = ancientStartTiles[Math.floor(Math.random() * ancientStartTiles.length)];
                ancientStart.building = BUILDING_TYPES.ANCIENT_RUIN;
                ancientStart.owner = FACTIONS.ANCIENT;
                ancientStart.units = spawnFactionUnits(UNIT_TYPES.GOLEM, UNIT_TYPES.ELEMENTAL);
                ancientStart.unitOrigins = [{ q: ancientStart.q, r: ancientStart.r, turn: 0 }];

                const neighbors = getNeighbors(ancientStart.q, ancientStart.r);
                let groupsPlaced = 0;
                for (let neighbor of neighbors) {
                    if (groupsPlaced >= 2) break;
                    const key = `${neighbor.q},${neighbor.r}`;
                    const hex = hexMap.get(key);
                    if (hex && hex.type === TILE_TYPES.LAND && !hex.building && hex.units.length === 0) {
                        hex.units = spawnFactionUnits(UNIT_TYPES.GOLEM, UNIT_TYPES.ELEMENTAL);
                        hex.owner = FACTIONS.ANCIENT;
                        hex.unitOrigins = [{ q: ancientStart.q, r: ancientStart.r, turn: 0 }];
                        groupsPlaced++;
                    }
                }
            }

            const beastStartTiles = landTiles.filter(hex => hex.distance > 10 && hex.distance < 25 && !hex.building);
            if (beastStartTiles.length > 0) {
                const beastStart = beastStartTiles[Math.floor(Math.random() * beastStartTiles.length)];
                beastStart.building = BUILDING_TYPES.BEAST_DEN;
                beastStart.owner = FACTIONS.BEAST;
                beastStart.units = spawnFactionUnits(UNIT_TYPES.WOLF, UNIT_TYPES.BEAR);
                beastStart.unitOrigins = [{ q: beastStart.q, r: beastStart.r, turn: 0 }];

                const neighbors = getNeighbors(beastStart.q, beastStart.r);
                let groupsPlaced = 0;
                for (let neighbor of neighbors) {
                    if (groupsPlaced >= 2) break;
                    const key = `${neighbor.q},${neighbor.r}`;
                    const hex = hexMap.get(key);
                    if (hex && hex.type === TILE_TYPES.LAND && !hex.building && hex.units.length === 0) {
                        hex.units = spawnFactionUnits(UNIT_TYPES.WOLF, UNIT_TYPES.BEAR);
                        hex.owner = FACTIONS.BEAST;
                        hex.unitOrigins = [{ q: beastStart.q, r: beastStart.r, turn: 0 }];
                        groupsPlaced++;
                    }
                }
            }

            const natureStartTiles = landTiles.filter(hex => hex.distance > 10 && hex.distance < 25 && !hex.building);
            if (natureStartTiles.length > 0) {
                const natureStart = natureStartTiles[Math.floor(Math.random() * natureStartTiles.length)];
                natureStart.building = BUILDING_TYPES.NATURE_GROVE;
                natureStart.owner = FACTIONS.NATURE;
                natureStart.units = spawnFactionUnits(UNIT_TYPES.TREANT, UNIT_TYPES.DEER);
                natureStart.unitOrigins = [{ q: natureStart.q, r: natureStart.r, turn: 0 }];

                const neighbors = getNeighbors(natureStart.q, natureStart.r);
                let groupsPlaced = 0;
                for (let neighbor of neighbors) {
                    if (groupsPlaced >= 2) break;
                    const key = `${neighbor.q},${neighbor.r}`;
                    const hex = hexMap.get(key);
                    if (hex && hex.type === TILE_TYPES.LAND && !hex.building && hex.units.length === 0) {
                        hex.units = spawnFactionUnits(UNIT_TYPES.TREANT, UNIT_TYPES.DEER);
                        hex.owner = FACTIONS.NATURE;
                        hex.unitOrigins = [{ q: natureStart.q, r: natureStart.r, turn: 0 }];
                        groupsPlaced++;
                    }
                }
            }
            
            for (let i = 0; i < 20; i++) {
                const tile = landTiles[Math.floor(Math.random() * landTiles.length)];
                if (!tile.building) {
                    tile.building = BUILDING_TYPES.GOLD_MINE;
                }
            }
            
            for (let i = 0; i < 24; i++) {
                const tile = landTiles[Math.floor(Math.random() * landTiles.length)];
                if (!tile.building) {
                    tile.building = BUILDING_TYPES.FARM;
                }
            }
            
            for (let i = 0; i < 20; i++) {
                const tile = landTiles[Math.floor(Math.random() * landTiles.length)];
                if (!tile.building) {
                    tile.building = BUILDING_TYPES.WATCHTOWER;
                }
            }
            
            for (let i = 0; i < 8; i++) {
                const tile = landTiles[Math.floor(Math.random() * landTiles.length)];
                if (!tile.building) {
                    tile.building = BUILDING_TYPES.ABANDONED_CASTLE;
                }
            }
        }
        
        // Draw units
        // Draw custom wolf on canvas
        function drawWolf(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Wolf colors - lighter white-gray
            const furColor = '#c0c0c0';
            const darkFur = '#909090';
            const eyeColor = '#ff0000';

            // Back legs (moved further left)
            ctx.fillStyle = furColor;
            ctx.fillRect(-6.5, 0, 1.5, 7);
            ctx.fillRect(-4.5, 0, 1.5, 7);

            // Back paws
            ctx.fillRect(-6.5, 7, 2, 1.5);
            ctx.fillRect(-4.5, 7, 2, 1.5);

            // Thinner body
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(-2, 0, 5, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail (curved upward)
            ctx.fillStyle = darkFur;
            ctx.beginPath();
            ctx.moveTo(-7, 0);
            ctx.quadraticCurveTo(-9, -2, -8, -5);
            ctx.quadraticCurveTo(-7, -2, -6, 0);
            ctx.closePath();
            ctx.fill();

            // Front legs (moved to right edge of body)
            ctx.fillStyle = furColor;
            ctx.fillRect(1, 0, 1.5, 7);
            ctx.fillRect(2.5, 0, 1.5, 7);

            // Front paws
            ctx.fillRect(1, 7, 2, 1.5);
            ctx.fillRect(2.5, 7, 2, 1.5);

            // Angled neck from body to head (closer to body)
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.moveTo(3, 0);
            ctx.lineTo(3, -1.5);
            ctx.lineTo(5, -4);
            ctx.lineTo(5, -2);
            ctx.closePath();
            ctx.fill();

            // Shorter head (closer to body)
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(6.5, -4, 3.5, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout/muzzle (elongated)
            ctx.fillStyle = darkFur;
            ctx.beginPath();
            ctx.ellipse(9.5, -3.5, 2.5, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(12, -3.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Thicker, longer, closer together pointed ears
            ctx.fillStyle = darkFur;
            ctx.beginPath();
            ctx.moveTo(5, -5.5);
            ctx.lineTo(4, -9);
            ctx.lineTo(6, -5);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(7, -5.5);
            ctx.lineTo(6, -9);
            ctx.lineTo(8, -5);
            ctx.closePath();
            ctx.fill();

            // Eye (big red pointy)
            ctx.fillStyle = eyeColor;
            ctx.beginPath();
            ctx.moveTo(6, -4.5);
            ctx.lineTo(7, -3);
            ctx.lineTo(8, -4.5);
            ctx.lineTo(7, -6);
            ctx.closePath();
            ctx.fill();

            // Pupil (vertical slit)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(7, -3.5);
            ctx.lineTo(7.2, -4);
            ctx.lineTo(7, -5.5);
            ctx.lineTo(6.8, -4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Draw custom bear on canvas
        function drawBear(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Bear colors - brown
            const furColor = '#8B4513';
            const darkFur = '#654321';
            const lightFur = '#A0522D';
            const eyeColor = '#ff0000';

            // Back legs (thick and sturdy)
            ctx.fillStyle = furColor;
            ctx.fillRect(-6, 1, 2.5, 6);
            ctx.fillRect(-3, 1, 2.5, 6);

            // Back paws (large)
            ctx.fillStyle = darkFur;
            ctx.fillRect(-6.5, 7, 3.5, 2);
            ctx.fillRect(-3.5, 7, 3.5, 2);

            // Large round body
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Front legs (thick and sturdy)
            ctx.fillStyle = furColor;
            ctx.fillRect(2, 1, 2.5, 6);
            ctx.fillRect(5, 1, 2.5, 6);

            // Front paws (large)
            ctx.fillStyle = darkFur;
            ctx.fillRect(1.5, 7, 3.5, 2);
            ctx.fillRect(4.5, 7, 3.5, 2);

            // Thick neck
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(5, -1, 2, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Large round head
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(7, -3, 3.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Shorter snout
            ctx.fillStyle = lightFur;
            ctx.beginPath();
            ctx.ellipse(9.5, -2.5, 2, 1.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(11, -2.5, 0.9, 0, Math.PI * 2);
            ctx.fill();

            // Small round ears
            ctx.fillStyle = darkFur;
            ctx.beginPath();
            ctx.arc(5, -5, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(8, -5.5, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Inner ear
            ctx.fillStyle = lightFur;
            ctx.beginPath();
            ctx.arc(5, -5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(8, -5.5, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (big red pointy)
            ctx.fillStyle = eyeColor;
            // Left eye
            ctx.beginPath();
            ctx.moveTo(5.5, -3.5);
            ctx.lineTo(6.5, -2.2);
            ctx.lineTo(7.5, -3.5);
            ctx.lineTo(6.5, -4.8);
            ctx.closePath();
            ctx.fill();

            // Right eye
            ctx.beginPath();
            ctx.moveTo(7.5, -3.5);
            ctx.lineTo(8.5, -2.2);
            ctx.lineTo(9.5, -3.5);
            ctx.lineTo(8.5, -4.8);
            ctx.closePath();
            ctx.fill();

            // Pupils (vertical slits)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(6.5, -2.8);
            ctx.lineTo(6.7, -3.2);
            ctx.lineTo(6.5, -4.2);
            ctx.lineTo(6.3, -3.2);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(8.5, -2.8);
            ctx.lineTo(8.7, -3.2);
            ctx.lineTo(8.5, -4.2);
            ctx.lineTo(8.3, -3.2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Draw custom elemental on canvas
        function drawElemental(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Elemental colors - swirling air/wind
            const coreColor = '#E0F0FF';
            const windColor = '#A0D0FF';
            const darkWind = '#6090C0';
            const glowColor = '#FFFFFF';

            // Central swirling core (tornado shape)
            ctx.fillStyle = coreColor;
            ctx.beginPath();
            // Bottom wider
            ctx.moveTo(-4, 8);
            ctx.quadraticCurveTo(-5, 4, -3, 0);
            ctx.quadraticCurveTo(-2, -4, 0, -8);
            ctx.quadraticCurveTo(2, -4, 3, 0);
            ctx.quadraticCurveTo(5, 4, 4, 8);
            ctx.closePath();
            ctx.fill();

            // Swirl lines (wind currents)
            ctx.strokeStyle = windColor;
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';

            // Left swirl
            ctx.beginPath();
            ctx.moveTo(-6, 6);
            ctx.quadraticCurveTo(-7, 3, -4, 2);
            ctx.quadraticCurveTo(-2, 1, -1, -2);
            ctx.stroke();

            // Right swirl
            ctx.beginPath();
            ctx.moveTo(6, 5);
            ctx.quadraticCurveTo(7, 2, 4, 1);
            ctx.quadraticCurveTo(2, 0, 1, -3);
            ctx.stroke();

            // Top swirl
            ctx.beginPath();
            ctx.moveTo(-2, -6);
            ctx.quadraticCurveTo(0, -7, 2, -6);
            ctx.quadraticCurveTo(3, -5, 2, -3);
            ctx.stroke();

            // Dark wind accents
            ctx.strokeStyle = darkWind;
            ctx.lineWidth = 1;

            // Curved accent lines
            ctx.beginPath();
            ctx.moveTo(-5, 7);
            ctx.quadraticCurveTo(-3, 5, -2, 3);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(5, 6);
            ctx.quadraticCurveTo(3, 4, 2, 2);
            ctx.stroke();

            // Glowing center/core
            ctx.fillStyle = glowColor;
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.ellipse(0, -2, 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Energy particles/wisps
            ctx.fillStyle = windColor;
            ctx.beginPath();
            ctx.arc(-4, -1, 0.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(4, 0, 0.7, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, -6, 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(-2, 4, 0.7, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(3, 3, 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw custom deer on canvas
        function drawDeer(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Deer colors - brown/tan
            const furColor = '#A0826D';
            const darkFur = '#8B6F47';
            const lightFur = '#C9B18F';
            const noseColor = '#000';

            // Back legs (slender)
            ctx.fillStyle = furColor;
            ctx.fillRect(-4, 0, 0.9, 7);
            ctx.fillRect(-2.5, 0, 0.9, 7);

            // Back hooves (black)
            ctx.fillStyle = noseColor;
            ctx.fillRect(-4, 7, 0.9, 1.2);
            ctx.fillRect(-2.5, 7, 0.9, 1.2);

            // Front legs (slender)
            ctx.fillStyle = furColor;
            ctx.fillRect(2, 0, 0.9, 7);
            ctx.fillRect(3.5, 0, 0.9, 7);

            // Front hooves (black)
            ctx.fillStyle = noseColor;
            ctx.fillRect(2, 7, 0.9, 1.2);
            ctx.fillRect(3.5, 7, 0.9, 1.2);

            // Body (slender and graceful)
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lighter belly
            ctx.fillStyle = lightFur;
            ctx.beginPath();
            ctx.ellipse(0, 1, 3.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Elegant neck (thicker)
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.moveTo(4.5, -0.5);
            ctx.lineTo(4.5, -2.5);
            ctx.lineTo(7, -5.5);
            ctx.lineTo(7.5, -3);
            ctx.closePath();
            ctx.fill();

            // Head (elongated)
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(8, -5, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout (lighter)
            ctx.fillStyle = lightFur;
            ctx.beginPath();
            ctx.ellipse(10, -4.5, 1.5, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = noseColor;
            ctx.beginPath();
            ctx.arc(11, -4.5, 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Antlers (branching, majestic)
            ctx.strokeStyle = darkFur;
            ctx.lineWidth = 1.2;
            ctx.lineCap = 'round';

            // Left antler main beam
            ctx.beginPath();
            ctx.moveTo(7, -6);
            ctx.lineTo(6, -9);
            ctx.lineTo(5.5, -11);
            ctx.stroke();

            // Left antler branches
            ctx.beginPath();
            ctx.moveTo(6.2, -8);
            ctx.lineTo(5, -9);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(6, -9.5);
            ctx.lineTo(4.5, -10);
            ctx.stroke();

            // Right antler main beam
            ctx.beginPath();
            ctx.moveTo(8.5, -6.5);
            ctx.lineTo(9, -9);
            ctx.lineTo(9.5, -11);
            ctx.stroke();

            // Right antler branches
            ctx.beginPath();
            ctx.moveTo(8.8, -8);
            ctx.lineTo(10, -9);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(9, -9.5);
            ctx.lineTo(10.5, -10);
            ctx.stroke();

            // Ears
            ctx.fillStyle = furColor;
            ctx.beginPath();
            ctx.ellipse(7, -6.5, 0.8, 1.5, -0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(8.5, -6.5, 0.8, 1.5, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Inner ear (lighter)
            ctx.fillStyle = lightFur;
            ctx.beginPath();
            ctx.ellipse(7, -6.5, 0.4, 0.8, -0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(8.5, -6.5, 0.4, 0.8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = noseColor;
            ctx.beginPath();
            ctx.arc(7.5, -5, 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlight
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(7.6, -5.1, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Small tail
            ctx.fillStyle = darkFur;
            ctx.beginPath();
            ctx.ellipse(-5, -1, 0.8, 1.5, -0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw custom goblin on canvas
        function drawGoblin(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Skin color
            const skinColor = '#7a9a3a';
            const darkSkin = '#5a7a2a';

            // Slim legs (drawn first, behind everything) - start at bottom of torso (y=2)
            ctx.fillStyle = skinColor;
            ctx.fillRect(-2, 2, 1.5, 6);
            ctx.fillRect(0.5, 2, 1.5, 6);

            // Pointy feet
            ctx.beginPath();
            ctx.moveTo(-2, 8);
            ctx.lineTo(-0.5, 8);
            ctx.lineTo(-1.25, 10);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0.5, 8);
            ctx.lineTo(2, 8);
            ctx.lineTo(1.25, 10);
            ctx.closePath();
            ctx.fill();

            // Brown skirt (upside down triangle) - over the legs
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.moveTo(-3, 2);
            ctx.lineTo(3, 2);
            ctx.lineTo(0, 6);
            ctx.closePath();
            ctx.fill();

            // Slim torso
            ctx.fillStyle = skinColor;
            ctx.fillRect(-2, -4, 4, 6);

            // Head (slim oval)
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(0, -8, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Thicker long pointy ears
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.moveTo(-3, -10);
            ctx.lineTo(-2, -8.5);
            ctx.lineTo(-5.5, -11);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(3, -10);
            ctx.lineTo(2, -8.5);
            ctx.lineTo(5.5, -11);
            ctx.closePath();
            ctx.fill();

            // Thicker long pointy nose (lower position)
            ctx.fillStyle = darkSkin;
            ctx.beginPath();
            ctx.moveTo(3, -7);
            ctx.lineTo(2.5, -5.5);
            ctx.lineTo(6, -4);
            ctx.closePath();
            ctx.fill();

            // Bigger angry red eyes (pointy)
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(-2, -9.5);
            ctx.lineTo(-0.5, -8.5);
            ctx.lineTo(-2, -7.5);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(1.5, -9.5);
            ctx.lineTo(0, -8.5);
            ctx.lineTo(1.5, -7.5);
            ctx.closePath();
            ctx.fill();

            // Spear in hand
            ctx.strokeStyle = '#4a3520';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(3, 0);
            ctx.lineTo(10, -6);
            ctx.stroke();

            // Spear tip
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(10, -6);
            ctx.lineTo(11, -8);
            ctx.lineTo(9, -7);
            ctx.closePath();
            ctx.fill();

            // Arm holding spear
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(2, 0);
            ctx.lineTo(4, -1);
            ctx.stroke();

            ctx.restore();
        }

        // Draw custom archer on canvas
        function drawArcher(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Skin color
            const skinColor = '#7a9a3a';
            const darkSkin = '#5a7a2a';

            // Slim legs (drawn first, behind everything) - start at bottom of torso (y=2)
            ctx.fillStyle = skinColor;
            ctx.fillRect(-2, 2, 1.5, 6);
            ctx.fillRect(0.5, 2, 1.5, 6);

            // Pointy feet
            ctx.beginPath();
            ctx.moveTo(-2, 8);
            ctx.lineTo(-0.5, 8);
            ctx.lineTo(-1.25, 10);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0.5, 8);
            ctx.lineTo(2, 8);
            ctx.lineTo(1.25, 10);
            ctx.closePath();
            ctx.fill();

            // Brown skirt (upside down triangle) - over the legs
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.moveTo(-3, 2);
            ctx.lineTo(3, 2);
            ctx.lineTo(0, 6);
            ctx.closePath();
            ctx.fill();

            // Quiver on back (brown rectangle with arrows)
            ctx.fillStyle = '#5a4a2a';
            ctx.fillRect(-3.5, -2, 1.5, 5);

            // Arrow fletching in quiver (3 arrows)
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3.2, -2, 0.4, 1);
            ctx.fillRect(-3.2, -0.5, 0.4, 1);
            ctx.fillRect(-3.2, 1, 0.4, 1);

            // Slim torso
            ctx.fillStyle = skinColor;
            ctx.fillRect(-2, -4, 4, 6);

            // Head (slim oval)
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(0, -8, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Thicker long pointy ears
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.moveTo(-3, -10);
            ctx.lineTo(-2, -8.5);
            ctx.lineTo(-5.5, -11);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(3, -10);
            ctx.lineTo(2, -8.5);
            ctx.lineTo(5.5, -11);
            ctx.closePath();
            ctx.fill();

            // Thicker long pointy nose (lower position)
            ctx.fillStyle = darkSkin;
            ctx.beginPath();
            ctx.moveTo(3, -7);
            ctx.lineTo(2.5, -5.5);
            ctx.lineTo(6, -4);
            ctx.closePath();
            ctx.fill();

            // Bigger angry red eyes (pointy)
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(-2, -9.5);
            ctx.lineTo(-0.5, -8.5);
            ctx.lineTo(-2, -7.5);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(1.5, -9.5);
            ctx.lineTo(0, -8.5);
            ctx.lineTo(1.5, -7.5);
            ctx.closePath();
            ctx.fill();

            // Bow (curved stick) - rotated like spear/staff
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            // More curved bow from bottom-right to top-left
            ctx.moveTo(3, 2);
            ctx.quadraticCurveTo(10, -2, 11, -7);
            ctx.stroke();

            // Bowstring (white straight line connecting the tips)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(3, 2);
            ctx.lineTo(11, -7);
            ctx.stroke();

            // Arrow nocked in bow
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(6.5, -2.5);
            ctx.lineTo(-2, -2);
            ctx.stroke();

            // Arrow tip
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(-2, -2);
            ctx.lineTo(-3.5, -2.8);
            ctx.lineTo(-3.5, -1.2);
            ctx.closePath();
            ctx.fill();

            // Arrow fletching
            ctx.fillStyle = '#ff6347';
            ctx.beginPath();
            ctx.moveTo(6, -3);
            ctx.lineTo(6.5, -2.5);
            ctx.lineTo(6, -2);
            ctx.closePath();
            ctx.fill();

            // Arm holding bow
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(2, 0);
            ctx.lineTo(4, 1);
            ctx.stroke();

            ctx.restore();
        }

        // Draw custom shaman on canvas
        function drawShaman(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Black robe colors
            const robeColor = '#1a1a1a';
            const robeShadow = '#0a0a0a';

            // Long flowing robe (bell shape)
            ctx.fillStyle = robeColor;
            ctx.beginPath();
            ctx.moveTo(-4, -2);
            ctx.lineTo(-5, 10);
            ctx.lineTo(5, 10);
            ctx.lineTo(4, -2);
            ctx.closePath();
            ctx.fill();

            // Robe shadows/folds
            ctx.fillStyle = robeShadow;
            ctx.beginPath();
            ctx.moveTo(-1, 0);
            ctx.lineTo(-2, 10);
            ctx.lineTo(0, 10);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(1.5, 2);
            ctx.lineTo(2.5, 10);
            ctx.lineTo(3.5, 10);
            ctx.closePath();
            ctx.fill();

            // Hood (covers head)
            ctx.fillStyle = robeColor;
            ctx.beginPath();
            ctx.ellipse(0, -8, 4.5, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hood shadow/depth
            ctx.fillStyle = robeShadow;
            ctx.beginPath();
            ctx.ellipse(0, -7, 3.5, 3.5, 0, 0, Math.PI);
            ctx.fill();

            // Green goblin face peeking from hood
            const skinColor = '#7a9a3a';

            // Face (smaller, in hood shadow)
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(0, -7.5, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Glowing red eyes in shadow
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 2;
            ctx.beginPath();
            ctx.arc(-1.2, -8, 0.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(1.2, -8, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Staff (wooden) - from within robe
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(3, 3);
            ctx.lineTo(11, -8);
            ctx.stroke();

            // Crystal orb on staff (glowing)
            ctx.fillStyle = '#9370db';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(11, -8, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ba55d3';
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(11, -8, 1, 0, Math.PI * 2);
            ctx.fill();

            // Magical sparkles
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(10, -6, 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(12.5, -7, 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.arc(10.5, -9.5, 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1.0;

            // Sleeve/arm from robe
            ctx.fillStyle = robeColor;
            ctx.beginPath();
            ctx.moveTo(3, 0);
            ctx.lineTo(5, 1);
            ctx.lineTo(4, 3);
            ctx.lineTo(2, 2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Draw custom golem on canvas
        function drawGolem(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Stone colors
            const stone1 = '#6b6b6b';
            const stone2 = '#7a7a7a';
            const stone3 = '#555555';
            const eyeGlow = '#00d4ff';

            // Helper function to draw irregular diamond
            function drawDiamond(cx, cy, w, h, angle = 0) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -h/2);
                ctx.lineTo(w/2, 0);
                ctx.lineTo(0, h/2);
                ctx.lineTo(-w/2, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Right leg rocks (back, furthest right)
            ctx.fillStyle = stone3;
            drawDiamond(3.5, 5, 2.5, 4, 0.3);
            ctx.fillStyle = stone2;
            drawDiamond(3, 8, 2, 3.5, 0.2);

            // Left leg rocks (front, less to right)
            ctx.fillStyle = stone2;
            drawDiamond(0, 5, 2.5, 4, -0.2);
            ctx.fillStyle = stone1;
            drawDiamond(-0.5, 8, 2, 3.5, -0.1);

            // Lower torso rock (large central diamond, angled right)
            ctx.fillStyle = stone1;
            drawDiamond(1.5, 1, 5, 5, 0.2);

            // Mid torso rock (offset right)
            ctx.fillStyle = stone3;
            drawDiamond(2, -2.5, 4.5, 4, 0.15);

            // Right shoulder/arm rocks
            ctx.fillStyle = stone2;
            drawDiamond(5, -3, 2.5, 3, 0.4);
            ctx.fillStyle = stone1;
            drawDiamond(6.5, 0, 2, 3.5, 0.3);

            // Left shoulder rock
            ctx.fillStyle = stone3;
            drawDiamond(-1.5, -3.5, 2.5, 3, -0.3);

            // Head rock (large, angled right)
            ctx.fillStyle = stone1;
            drawDiamond(2, -7, 5, 5, 0.2);

            // Small head accent rocks
            ctx.fillStyle = stone2;
            drawDiamond(0, -9, 2, 2.5, 0.1);
            ctx.fillStyle = stone3;
            drawDiamond(4, -8.5, 1.8, 2.2, 0.3);

            // Big bright blue glowing eyes
            ctx.fillStyle = eyeGlow;
            ctx.shadowColor = eyeGlow;
            ctx.shadowBlur = 3;

            // Left eye
            ctx.beginPath();
            ctx.arc(0.5, -7.5, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Right eye
            ctx.beginPath();
            ctx.arc(3.5, -7, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Eye pupils (darker blue)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#0088cc';
            ctx.beginPath();
            ctx.arc(0.5, -7.5, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(3.5, -7, 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw custom treant on canvas
        function drawTreent(ctx, x, y, size, flip = false) {
            ctx.save();
            ctx.translate(x, y);
            if (flip) {
                ctx.scale(-1, 1);
            }

            const scale = size / 20; // Base size is 20
            ctx.scale(scale, scale);

            // Tree colors
            const darkGreen = '#2d5016';
            const midGreen = '#3d6b1f';
            const lightGreen = '#4d7d28';
            const brown = '#5c4033';

            // Legs (simple branches pointing down)
            ctx.strokeStyle = brown;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(-1, 7);
            ctx.lineTo(-2, 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(1, 7);
            ctx.lineTo(2, 10);
            ctx.stroke();

            // Short trunk/stem
            ctx.fillStyle = brown;
            ctx.fillRect(-1.5, 4, 3, 5);

            // Arms (branches pointing down from trunk)
            ctx.strokeStyle = brown;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1.5, 6);
            ctx.lineTo(-4, 8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(1.5, 6);
            ctx.lineTo(4, 8);
            ctx.stroke();

            // Pine tree layers (bottom to top, getting smaller)
            // Bottom layer
            ctx.fillStyle = darkGreen;
            ctx.beginPath();
            ctx.moveTo(-6, 4);
            ctx.lineTo(6, 4);
            ctx.lineTo(0, -1);
            ctx.closePath();
            ctx.fill();

            // Middle layer
            ctx.fillStyle = midGreen;
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.lineTo(5, 0);
            ctx.lineTo(0, -5);
            ctx.closePath();
            ctx.fill();

            // Top layer
            ctx.fillStyle = lightGreen;
            ctx.beginPath();
            ctx.moveTo(-4, -4);
            ctx.lineTo(4, -4);
            ctx.lineTo(0, -9);
            ctx.closePath();
            ctx.fill();

            // Tip
            ctx.fillStyle = lightGreen;
            ctx.beginPath();
            ctx.moveTo(-2, -8);
            ctx.lineTo(2, -8);
            ctx.lineTo(0, -11);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Sprite caching system for performance
        const unitSprites = {};

        function cacheUnitSprites() {
            // Define unit types and their corresponding draw functions
            const unitConfigs = [
                { name: 'Goblin', drawFn: drawGoblin, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Goblin Archer', drawFn: drawArcher, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Goblin Shaman', drawFn: drawShaman, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Wolf', drawFn: drawWolf, baseSizes: [6, 9, 13, 18, 27] },
                { name: 'Bear', drawFn: drawBear, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Stone Golem', drawFn: drawGolem, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Treant', drawFn: drawTreent, baseSizes: [12, 18, 25, 36, 50] },
                { name: 'Elemental', drawFn: drawElemental, baseSizes: [10, 14, 20, 28, 42] },
                { name: 'Deer', drawFn: drawDeer, baseSizes: [8, 11, 16, 22, 33] }
            ];

            unitConfigs.forEach(config => {
                unitSprites[config.name] = {};

                config.baseSizes.forEach(size => {
                    // Create offscreen canvas with padding for unit graphics
                    const canvas = document.createElement('canvas');
                    const padding = size * 1.5; // Extra space for larger unit graphics
                    canvas.width = padding * 2;
                    canvas.height = padding * 2;
                    const ctx = canvas.getContext('2d');

                    // Draw unit centered in the canvas
                    config.drawFn(ctx, padding, padding, size);

                    unitSprites[config.name][size] = canvas;
                });
            });
        }

        function findClosestSpriteSize(targetSize, unitName) {
            const availableSizes = Object.keys(unitSprites[unitName] || {}).map(Number).sort((a, b) => a - b);
            if (availableSizes.length === 0) return null;

            // Find closest size (prefer slightly larger for better quality)
            let closest = availableSizes[0];
            let minDiff = Math.abs(targetSize - closest);

            for (const size of availableSizes) {
                const diff = Math.abs(targetSize - size);
                // Prefer larger sizes when difference is similar (within 20%)
                if (diff < minDiff || (diff <= minDiff * 1.2 && size > closest)) {
                    closest = size;
                    minDiff = diff;
                }
            }

            return closest;
        }

        // Skull and footprint sprite caching for performance
        const skullSprites = {};
        const footprintSprites = {};

        function cacheSkullSprites() {
            // Pre-render skulls at different rotations and zoom levels
            const rotations = 8; // 8 rotations = 45¬∞ increments
            const zoomLevels = [0.5, 1.0, 1.5, 2.0, 3.0];

            zoomLevels.forEach(zoomLevel => {
                skullSprites[zoomLevel] = {};

                for (let i = 0; i < rotations; i++) {
                    const rotation = (i * Math.PI * 2) / rotations;
                    const fontSize = Math.max(2, 3 * zoomLevel);

                    // Create offscreen canvas
                    const canvas = document.createElement('canvas');
                    const size = Math.ceil(fontSize * 2.5); // Extra space for rotation
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Draw skull emoji with rotation
                    ctx.save();
                    ctx.translate(size / 2, size / 2);
                    ctx.rotate(rotation);
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 1;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText('üíÄ', 0, 0);
                    ctx.restore();

                    skullSprites[zoomLevel][i] = canvas;
                }
            });
        }

        function cacheFootprintSprites() {
            // Pre-render footprints at different rotations and zoom levels
            const rotations = 16; // 16 rotations = 22.5¬∞ increments
            const zoomLevels = [0.8, 1.0, 1.5, 2.0, 3.0];

            zoomLevels.forEach(zoomLevel => {
                footprintSprites[zoomLevel] = {};

                for (let i = 0; i < rotations; i++) {
                    const rotation = (i * Math.PI * 2) / rotations;
                    const printSize = 2 * zoomLevel;

                    // Create offscreen canvas
                    const canvas = document.createElement('canvas');
                    const size = Math.ceil(printSize * 4); // Extra space for rotation
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Draw footprint with rotation
                    ctx.save();
                    ctx.translate(size / 2, size / 2);
                    ctx.rotate(rotation);

                    // Toe ellipse
                    ctx.fillStyle = 'rgba(100, 80, 60, 1)'; // Will be adjusted with globalAlpha
                    ctx.beginPath();
                    ctx.ellipse(0, -printSize * 0.8, printSize * 0.6, printSize * 1, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Heel ellipse
                    ctx.beginPath();
                    ctx.ellipse(0, printSize * 0.6, printSize * 0.5, printSize * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();

                    footprintSprites[zoomLevel][i] = canvas;
                }
            });
        }

        function findClosestZoomLevel(currentZoom, availableLevels) {
            let closest = availableLevels[0];
            let minDiff = Math.abs(currentZoom - closest);

            for (const level of availableLevels) {
                const diff = Math.abs(currentZoom - level);
                if (diff < minDiff) {
                    closest = level;
                    minDiff = diff;
                }
            }

            return closest;
        }

        function findClosestRotation(targetRotation, numRotations) {
            const normalized = ((targetRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            const index = Math.round((normalized / (Math.PI * 2)) * numRotations) % numRotations;
            return index;
        }

        // Building sprite caching for performance
        const buildingSprites = {};
        let buildingCacheInitialized = false;

        function initBuildingCache() {
            if (buildingCacheInitialized) return;

            // Building caching disabled - ctx is constant and cannot be reassigned
            // Buildings will use fallback rendering (still reasonably fast)
            // This maintains compatibility without requiring major refactoring
            buildingCacheInitialized = true;

            // Note: To enable building caching, drawBuilding would need to be refactored
            // to accept ctx and zoom as parameters instead of using globals
        }

        function cacheBuildingSprites() {
            // This will be called later after drawBuilding is defined
            // Actual initialization happens in initBuildingCache
        }

        function drawUnits(hex) {
            if (hex.units.length === 0) return;

            const pos = hexToPixel(hex.q, hex.r);
            const unitCount = Math.min(hex.units.length, 9);
            const unitSize = 8 * zoom;
            
            const positions = [];
            if (unitCount === 1) {
                positions.push({ x: 0, y: 0 });
            } else if (unitCount === 2) {
                positions.push({ x: -unitSize, y: 0 }, { x: unitSize, y: 0 });
            } else if (unitCount === 3) {
                positions.push({ x: -unitSize, y: -unitSize/2 }, { x: unitSize, y: -unitSize/2 }, { x: 0, y: unitSize });
            } else if (unitCount <= 4) {
                positions.push({ x: -unitSize, y: -unitSize }, { x: unitSize, y: -unitSize },
                             { x: -unitSize, y: unitSize }, { x: unitSize, y: unitSize });
            } else if (unitCount <= 6) {
                for (let i = 0; i < 3; i++) {
                    positions.push({ x: -unitSize + i * unitSize, y: -unitSize });
                    if (positions.length < unitCount)
                        positions.push({ x: -unitSize + i * unitSize, y: unitSize });
                }
            } else {
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (positions.length < unitCount) {
                            positions.push({ x: -unitSize + j * unitSize, y: -unitSize + i * unitSize });
                        }
                    }
                }
            }
            
            ctx.font = `${Math.max(10, 14 * zoom)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < Math.min(unitCount, positions.length); i++) {
                const unit = hex.units[i];
                const unitX = pos.x + positions[i].x;
                const unitY = pos.y + positions[i].y;

                // Draw unit sprite from cache or fallback to direct drawing
                let targetSize = 14 * zoom;
                if (unit.name === 'Goblin' || unit.name === 'Goblin Archer' || unit.name === 'Goblin Shaman') {
                    targetSize = Math.max(10, 14 * zoom);
                } else if (unit.name === 'Wolf') {
                    targetSize = Math.max(6, 9 * zoom);
                } else if (unit.name === 'Bear' || unit.name === 'Stone Golem' || unit.name === 'Elemental') {
                    targetSize = Math.max(10, 14 * zoom);
                } else if (unit.name === 'Treant') {
                    targetSize = Math.max(12, 18 * zoom);
                } else if (unit.name === 'Deer') {
                    targetSize = Math.max(8, 11 * zoom);
                }

                // Try to use cached sprite
                const cachedSize = findClosestSpriteSize(targetSize, unit.name);
                if (cachedSize && unitSprites[unit.name] && unitSprites[unit.name][cachedSize]) {
                    const sprite = unitSprites[unit.name][cachedSize];
                    const scale = targetSize / cachedSize;
                    const drawWidth = sprite.width * scale;
                    const drawHeight = sprite.height * scale;
                    ctx.drawImage(sprite, unitX - drawWidth / 2, unitY - drawHeight / 2, drawWidth, drawHeight);
                } else {
                    // Fallback to direct drawing if cache miss
                    if (unit.name === 'Goblin') {
                        drawGoblin(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Goblin Archer') {
                        drawArcher(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Goblin Shaman') {
                        drawShaman(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Wolf') {
                        drawWolf(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Bear') {
                        drawBear(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Stone Golem') {
                        drawGolem(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Treant') {
                        drawTreent(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Elemental') {
                        drawElemental(ctx, unitX, unitY, targetSize);
                    } else if (unit.name === 'Deer') {
                        drawDeer(ctx, unitX, unitY, targetSize);
                    } else {
                        ctx.fillText(unit.symbol, unitX, unitY);
                    }
                }
                
                // Draw rank chevrons if unit has rank
                if (unit.rank && unit.rank > 0) {
                    ctx.save();
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.5;
                    ctx.font = `bold ${Math.max(6, 8 * zoom)}px Arial`;
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'top';
                    
                    let chevrons = '';
                    for (let r = 0; r < Math.min(unit.rank, 5); r++) {
                        chevrons += '‚åÉ';
                    }
                    
                    const chevronX = unitX + unitSize * 0.8;
                    const chevronY = unitY - unitSize * 0.8;
                    
                    ctx.strokeText(chevrons, chevronX, chevronY);
                    ctx.fillText(chevrons, chevronX, chevronY);
                    ctx.restore();
                }
            }
            
            if (hex.units.length > 9) {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.font = `bold ${Math.max(10, 12 * zoom)}px Arial`;
                const countText = `√ó${hex.units.length}`;
                ctx.strokeText(countText, pos.x, pos.y - HEX_SIZE * zoom * 0.7);
                ctx.fillText(countText, pos.x, pos.y - HEX_SIZE * zoom * 0.7);
            }
        }

        // Draw ship with units
        function drawShip(hex) {
            if (!hex.ship) {
                // Check if it's a wreck
                const wreck = game.wreckedShips.find(w => w.q === hex.q && w.r === hex.r);
                if (!wreck) return;

                // Draw wreck
                const pos = hexToPixel(hex.q, hex.r);
                const size = HEX_SIZE * zoom;

                ctx.save();
                ctx.globalAlpha *= wreck.opacity * 0.5; // Faded wreck

                // Draw broken ship hull
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.35, pos.y + size * 0.1);
                ctx.lineTo(pos.x + size * 0.35, pos.y + size * 0.1);
                ctx.lineTo(pos.x + size * 0.25, pos.y + size * 0.35);
                ctx.lineTo(pos.x - size * 0.25, pos.y + size * 0.35);
                ctx.closePath();
                ctx.fill();

                // Draw broken mast
                ctx.strokeStyle = '#4a3520';
                ctx.lineWidth = 2 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y + size * 0.1);
                ctx.lineTo(pos.x - size * 0.2, pos.y - size * 0.2);
                ctx.stroke();

                ctx.restore();
                return;
            }

            const pos = hexToPixel(hex.q, hex.r);
            const size = HEX_SIZE * zoom;

            ctx.save();

            // Draw ship hull
            ctx.fillStyle = '#8B4513';
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2 * zoom;
            ctx.beginPath();
            // Boat shape
            ctx.moveTo(pos.x - size * 0.4, pos.y);
            ctx.lineTo(pos.x + size * 0.4, pos.y);
            ctx.lineTo(pos.x + size * 0.3, pos.y + size * 0.3);
            ctx.lineTo(pos.x - size * 0.3, pos.y + size * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw deck
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(pos.x - size * 0.35, pos.y + size * 0.05, size * 0.7, size * 0.15);

            // Draw mast
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3 * zoom;
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y + size * 0.05);
            ctx.lineTo(pos.x, pos.y - size * 0.5);
            ctx.stroke();

            // Draw sail
            ctx.fillStyle = '#F5F5DC';
            ctx.strokeStyle = '#C8B896';
            ctx.lineWidth = 1 * zoom;
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y - size * 0.5);
            ctx.lineTo(pos.x + size * 0.3, pos.y - size * 0.25);
            ctx.lineTo(pos.x, pos.y - size * 0.05);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw flag at top
            const factionColor = getFactionColor(hex.ship.owner);
            ctx.fillStyle = factionColor;
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y - size * 0.5);
            const flagSize = size * 0.1;
            ctx.lineTo(pos.x + flagSize, pos.y - size * 0.5 + flagSize * 0.3);
            ctx.lineTo(pos.x, pos.y - size * 0.5 + flagSize * 0.6);
            ctx.closePath();
            ctx.fill();

            // Draw units on ship
            drawUnitsOnShip(hex.ship, pos, size);

            ctx.restore();
        }

        function drawUnitsOnShip(ship, pos, size) {
            const unitCount = Math.min(ship.units.length, 9);
            const spacing = size * 0.08;
            const startX = pos.x - (unitCount - 1) * spacing / 2;
            const y = pos.y + size * 0.15;

            for (let i = 0; i < unitCount; i++) {
                const unit = ship.units[i];
                const x = startX + i * spacing;

                // Draw tiny unit sprite
                const unitSize = Math.max(4, 6 * zoom);

                if (unit.name === 'Goblin') {
                    drawGoblin(ctx, x, y, unitSize);
                } else if (unit.name === 'Goblin Archer') {
                    drawArcher(ctx, x, y, unitSize);
                } else if (unit.name === 'Goblin Shaman') {
                    drawShaman(ctx, x, y, unitSize);
                }
            }
        }

        // Draw building
        function drawBuilding(hex) {
            if (!hex.building) return;

            const pos = hexToPixel(hex.q, hex.r);

            // Try to use cached sprite first
            const buildingName = hex.building.name;
            const zoomLevels = [0.5, 0.8, 1.0, 1.5, 2.0, 3.0];
            const closestZoom = findClosestZoomLevel(zoom, zoomLevels);

            if (buildingSprites[buildingName] && buildingSprites[buildingName][closestZoom]) {
                const sprite = buildingSprites[buildingName][closestZoom];
                const previousAlpha = ctx.globalAlpha;

                if (hex.building.resource) {
                    ctx.globalAlpha = previousAlpha * 0.5;
                }

                ctx.drawImage(sprite, pos.x - sprite.width / 2, pos.y - sprite.height / 2);

                ctx.globalAlpha = previousAlpha;

                // Draw recruitment flag if needed (still need to draw this)
                if (hex.building.produces) {
                    ctx.save();
                    ctx.fillStyle = getFactionColor(hex.building.faction);
                    ctx.globalAlpha = 0.7;
                    const flagSize = HEX_SIZE * zoom * 0.25;
                    ctx.beginPath();
                    ctx.moveTo(pos.x + HEX_SIZE * zoom * 0.5, pos.y - HEX_SIZE * zoom * 0.8);
                    ctx.lineTo(pos.x + HEX_SIZE * zoom * 0.5 + flagSize, pos.y - HEX_SIZE * zoom * 0.8 + flagSize * 0.3);
                    ctx.lineTo(pos.x + HEX_SIZE * zoom * 0.5, pos.y - HEX_SIZE * zoom * 0.8 + flagSize * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1 * zoom;
                    ctx.beginPath();
                    ctx.moveTo(pos.x + HEX_SIZE * zoom * 0.5, pos.y - HEX_SIZE * zoom * 0.8);
                    ctx.lineTo(pos.x + HEX_SIZE * zoom * 0.5, pos.y + HEX_SIZE * zoom * 0.3);
                    ctx.stroke();
                    ctx.restore();
                }
                return;
            }

            // Fallback to original drawing if no cache
            ctx.font = `${Math.max(14, 20 * zoom)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const previousAlpha = ctx.globalAlpha;

            if (hex.building.resource) {
                ctx.globalAlpha = previousAlpha * 0.5;
            }

            // Draw Goblin Fort as SVG
            if (hex.building.name === 'Goblin Fort' || hex.building.name === 'Fort') {
                const size = HEX_SIZE * zoom;
                const wallHeight = size * 0.6;

                ctx.save();

                // Draw wooden walls following hex edges
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 4 * zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw 6 wall segments around the hex
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle1 = (Math.PI / 3) * i + Math.PI / 6;
                    const angle2 = (Math.PI / 3) * (i + 1) + Math.PI / 6;

                    const x1 = pos.x + size * 0.7 * Math.cos(angle1);
                    const y1 = pos.y + size * 0.7 * Math.sin(angle1);
                    const x2 = pos.x + size * 0.7 * Math.cos(angle2);
                    const y2 = pos.y + size * 0.7 * Math.sin(angle2);

                    ctx.moveTo(x1, y1 - wallHeight * 0.3);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2, y2 - wallHeight * 0.3);
                }
                ctx.stroke();

                // Draw wooden tower in center
                const towerWidth = size * 0.4;
                const towerHeight = size * 0.8;

                // Tower base
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(pos.x - towerWidth / 2, pos.y - towerHeight / 2, towerWidth, towerHeight * 0.7);

                // Tower roof (triangular)
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.moveTo(pos.x - towerWidth * 0.6, pos.y - towerHeight / 2);
                ctx.lineTo(pos.x, pos.y - towerHeight);
                ctx.lineTo(pos.x + towerWidth * 0.6, pos.y - towerHeight / 2);
                ctx.closePath();
                ctx.fill();

                // Tower door
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(pos.x - towerWidth * 0.15, pos.y + towerHeight * 0.05, towerWidth * 0.3, towerHeight * 0.25);

                // Tower window
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(pos.x - towerWidth * 0.1, pos.y - towerHeight * 0.2, towerWidth * 0.2, towerWidth * 0.15);

                ctx.restore();
            } else if (hex.building.name === 'Goblin Fortress') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Draw stone walls following hex edges
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 6 * zoom;
                ctx.lineCap = 'square';
                ctx.lineJoin = 'miter';

                // Draw thicker stone walls
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle1 = (Math.PI / 3) * i + Math.PI / 6;
                    const angle2 = (Math.PI / 3) * (i + 1) + Math.PI / 6;

                    const x1 = pos.x + size * 0.8 * Math.cos(angle1);
                    const y1 = pos.y + size * 0.8 * Math.sin(angle1);
                    const x2 = pos.x + size * 0.8 * Math.cos(angle2);
                    const y2 = pos.y + size * 0.8 * Math.sin(angle2);

                    ctx.moveTo(x1, y1 - size * 0.4);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2, y2 - size * 0.4);
                }
                ctx.stroke();

                // Draw battlements on walls
                ctx.fillStyle = '#808080';
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + Math.PI / 6;
                    const x = pos.x + size * 0.8 * Math.cos(angle);
                    const y = pos.y + size * 0.8 * Math.sin(angle);

                    const battlementWidth = size * 0.12;
                    const battlementHeight = size * 0.15;

                    ctx.fillRect(x - battlementWidth / 2, y - size * 0.5, battlementWidth, battlementHeight);
                }

                // Draw main tower in center (larger)
                const mainTowerWidth = size * 0.5;
                const mainTowerHeight = size * 1.1;

                // Tower base (stone)
                ctx.fillStyle = '#696969';
                ctx.fillRect(pos.x - mainTowerWidth / 2, pos.y - mainTowerHeight / 2, mainTowerWidth, mainTowerHeight * 0.75);

                // Tower top (darker stone)
                ctx.fillStyle = '#505050';
                ctx.fillRect(pos.x - mainTowerWidth * 0.6 / 2, pos.y - mainTowerHeight / 2 - size * 0.2, mainTowerWidth * 0.6, size * 0.2);

                // Tower roof (pointed)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.moveTo(pos.x - mainTowerWidth * 0.7 / 2, pos.y - mainTowerHeight / 2 - size * 0.2);
                ctx.lineTo(pos.x, pos.y - mainTowerHeight);
                ctx.lineTo(pos.x + mainTowerWidth * 0.7 / 2, pos.y - mainTowerHeight / 2 - size * 0.2);
                ctx.closePath();
                ctx.fill();

                // Tower windows (multiple levels)
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(pos.x - mainTowerWidth * 0.12, pos.y - mainTowerHeight * 0.3, mainTowerWidth * 0.24, mainTowerWidth * 0.18);
                ctx.fillRect(pos.x - mainTowerWidth * 0.12, pos.y, mainTowerWidth * 0.24, mainTowerWidth * 0.18);

                // Gate
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(pos.x - mainTowerWidth * 0.2, pos.y + mainTowerHeight * 0.15, mainTowerWidth * 0.4, mainTowerHeight * 0.25);

                ctx.restore();
            } else if (hex.building.name === 'Ancient Ruin') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Draw mystical purple glow
                ctx.shadowColor = '#9932CC';
                ctx.shadowBlur = 15 * zoom;

                // Draw broken stone pillars
                const pillarWidth = size * 0.15;
                const pillarHeight = size * 0.9;

                // Left pillar (broken)
                ctx.fillStyle = '#8B8B83';
                ctx.fillRect(pos.x - size * 0.4, pos.y - pillarHeight * 0.3, pillarWidth, pillarHeight * 0.3);

                // Left pillar top (broken piece at angle)
                ctx.save();
                ctx.translate(pos.x - size * 0.32, pos.y - pillarHeight * 0.3);
                ctx.rotate(-0.3);
                ctx.fillRect(-pillarWidth / 2, -size * 0.2, pillarWidth, size * 0.2);
                ctx.restore();

                // Center pillar (tallest, intact)
                ctx.fillStyle = '#9B9B8F';
                ctx.fillRect(pos.x - pillarWidth / 2, pos.y - pillarHeight / 2, pillarWidth, pillarHeight);

                // Pillar capital
                ctx.fillStyle = '#A9A9A0';
                ctx.fillRect(pos.x - pillarWidth * 0.7, pos.y - pillarHeight / 2 - size * 0.1, pillarWidth * 1.4, size * 0.1);

                // Right pillar (broken)
                ctx.fillStyle = '#8B8B83';
                ctx.fillRect(pos.x + size * 0.4 - pillarWidth, pos.y - pillarHeight * 0.4, pillarWidth, pillarHeight * 0.4);

                // Ancient archway (partially collapsed)
                ctx.fillStyle = '#7B7B73';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.4, pos.y - pillarHeight * 0.25);
                ctx.lineTo(pos.x - size * 0.1, pos.y - pillarHeight * 0.5);
                ctx.lineTo(pos.x, pos.y - pillarHeight * 0.55);
                ctx.lineTo(pos.x, pos.y - pillarHeight * 0.45);
                ctx.lineTo(pos.x - size * 0.15, pos.y - pillarHeight * 0.4);
                ctx.lineTo(pos.x - size * 0.4, pos.y - pillarHeight * 0.2);
                ctx.closePath();
                ctx.fill();

                // Mystical glowing crystal in center
                ctx.shadowBlur = 10 * zoom;
                ctx.shadowColor = '#B565FF';
                ctx.fillStyle = '#9932CC';

                // Draw crystal shape (diamond)
                const crystalSize = size * 0.2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y - crystalSize);
                ctx.lineTo(pos.x + crystalSize * 0.5, pos.y);
                ctx.lineTo(pos.x, pos.y + crystalSize);
                ctx.lineTo(pos.x - crystalSize * 0.5, pos.y);
                ctx.closePath();
                ctx.fill();

                // Inner glow
                ctx.shadowBlur = 5 * zoom;
                ctx.fillStyle = '#B565FF';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y - crystalSize * 0.5);
                ctx.lineTo(pos.x + crystalSize * 0.25, pos.y);
                ctx.lineTo(pos.x, pos.y + crystalSize * 0.5);
                ctx.lineTo(pos.x - crystalSize * 0.25, pos.y);
                ctx.closePath();
                ctx.fill();

                // Mystical circles around crystal
                ctx.shadowBlur = 3 * zoom;
                ctx.strokeStyle = '#B565FF';
                ctx.lineWidth = 1.5 * zoom;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, crystalSize * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, crystalSize * 1.2, 0, Math.PI * 2);
                ctx.stroke();

                // Cracked stone base
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#696969';
                ctx.fillRect(pos.x - size * 0.5, pos.y + size * 0.2, size, size * 0.15);

                // Cracks in base
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.3, pos.y + size * 0.2);
                ctx.lineTo(pos.x - size * 0.2, pos.y + size * 0.35);
                ctx.moveTo(pos.x + size * 0.1, pos.y + size * 0.2);
                ctx.lineTo(pos.x, pos.y + size * 0.35);
                ctx.stroke();

                ctx.restore();
            } else if (hex.building.name === 'Farm') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Draw crop fields in background
                const fieldSize = size * 0.3;
                ctx.fillStyle = '#9ACD32'; // Yellow-green

                // Left field
                ctx.fillRect(pos.x - size * 0.6, pos.y - fieldSize / 2, fieldSize, fieldSize);
                // Right field
                ctx.fillRect(pos.x + size * 0.3, pos.y - fieldSize / 2, fieldSize, fieldSize);

                // Crop rows (darker lines)
                ctx.strokeStyle = '#6B8E23';
                ctx.lineWidth = 1 * zoom;
                for (let i = 0; i < 4; i++) {
                    const rowY = pos.y - fieldSize / 2 + (i * fieldSize / 3);
                    // Left field rows
                    ctx.beginPath();
                    ctx.moveTo(pos.x - size * 0.6, rowY);
                    ctx.lineTo(pos.x - size * 0.3, rowY);
                    ctx.stroke();
                    // Right field rows
                    ctx.beginPath();
                    ctx.moveTo(pos.x + size * 0.3, rowY);
                    ctx.lineTo(pos.x + size * 0.6, rowY);
                    ctx.stroke();
                }

                // Draw barn/farmhouse in center
                const barnWidth = size * 0.5;
                const barnHeight = size * 0.7;

                // Barn base (red wood)
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(pos.x - barnWidth / 2, pos.y - barnHeight / 3, barnWidth, barnHeight * 0.6);

                // Barn roof (gambrel style)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.moveTo(pos.x - barnWidth * 0.6, pos.y - barnHeight / 3);
                ctx.lineTo(pos.x - barnWidth * 0.4, pos.y - barnHeight * 0.65);
                ctx.lineTo(pos.x, pos.y - barnHeight * 0.8);
                ctx.lineTo(pos.x + barnWidth * 0.4, pos.y - barnHeight * 0.65);
                ctx.lineTo(pos.x + barnWidth * 0.6, pos.y - barnHeight / 3);
                ctx.closePath();
                ctx.fill();

                // Barn door
                ctx.fillStyle = '#654321';
                ctx.fillRect(pos.x - barnWidth * 0.15, pos.y + barnHeight * 0.05, barnWidth * 0.3, barnHeight * 0.22);

                // Hay loft window
                ctx.fillStyle = '#4a2511';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y - barnHeight * 0.3, barnWidth * 0.12, 0, Math.PI * 2);
                ctx.fill();

                // Fence posts
                ctx.fillStyle = '#654321';
                const postWidth = size * 0.04;
                const postHeight = size * 0.25;

                // Left fence posts
                ctx.fillRect(pos.x - size * 0.75, pos.y + size * 0.1, postWidth, postHeight);
                ctx.fillRect(pos.x - size * 0.5, pos.y + size * 0.1, postWidth, postHeight);

                // Right fence posts
                ctx.fillRect(pos.x + size * 0.5, pos.y + size * 0.1, postWidth, postHeight);
                ctx.fillRect(pos.x + size * 0.75, pos.y + size * 0.1, postWidth, postHeight);

                // Fence rails
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2 * zoom;
                // Left fence
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.75, pos.y + size * 0.15);
                ctx.lineTo(pos.x - size * 0.5, pos.y + size * 0.15);
                ctx.stroke();
                // Right fence
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.5, pos.y + size * 0.15);
                ctx.lineTo(pos.x + size * 0.75, pos.y + size * 0.15);
                ctx.stroke();

                ctx.restore();
            } else if (hex.building.name === 'Abandoned Tower') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Draw crumbling stone tower
                const towerWidth = size * 0.45;
                const towerHeight = size * 1.2;

                // Tower base (weathered stone)
                ctx.fillStyle = '#696969';
                ctx.fillRect(pos.x - towerWidth / 2, pos.y - towerHeight / 3, towerWidth, towerHeight * 0.7);

                // Cracks in tower walls
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                // Vertical crack
                ctx.moveTo(pos.x - towerWidth * 0.15, pos.y - towerHeight * 0.25);
                ctx.lineTo(pos.x - towerWidth * 0.2, pos.y + towerHeight * 0.1);
                // Diagonal crack
                ctx.moveTo(pos.x + towerWidth * 0.25, pos.y - towerHeight * 0.1);
                ctx.lineTo(pos.x + towerWidth * 0.1, pos.y + towerHeight * 0.2);
                ctx.stroke();

                // Broken/damaged top section
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                // Jagged broken top
                ctx.moveTo(pos.x - towerWidth / 2, pos.y - towerHeight / 3);
                ctx.lineTo(pos.x - towerWidth * 0.3, pos.y - towerHeight / 2);
                ctx.lineTo(pos.x - towerWidth * 0.1, pos.y - towerHeight * 0.4);
                ctx.lineTo(pos.x + towerWidth * 0.05, pos.y - towerHeight * 0.65);
                ctx.lineTo(pos.x + towerWidth * 0.2, pos.y - towerHeight * 0.55);
                ctx.lineTo(pos.x + towerWidth * 0.35, pos.y - towerHeight * 0.45);
                ctx.lineTo(pos.x + towerWidth / 2, pos.y - towerHeight / 3);
                ctx.closePath();
                ctx.fill();

                // Partially collapsed battlements
                ctx.fillStyle = '#5A5A5A';
                // Left battlement (intact)
                ctx.fillRect(pos.x - towerWidth * 0.4, pos.y - towerHeight * 0.5, towerWidth * 0.15, towerHeight * 0.12);
                // Center battlement (broken)
                ctx.fillRect(pos.x - towerWidth * 0.05, pos.y - towerHeight * 0.6, towerWidth * 0.1, towerHeight * 0.08);

                // Dark windows (arrow slits)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(pos.x - towerWidth * 0.12, pos.y - towerHeight * 0.15, towerWidth * 0.08, towerHeight * 0.15);
                ctx.fillRect(pos.x - towerWidth * 0.12, pos.y + towerHeight * 0.05, towerWidth * 0.08, towerHeight * 0.15);

                // Broken doorway at base
                ctx.fillStyle = '#2F2F2F';
                ctx.fillRect(pos.x - towerWidth * 0.25, pos.y + towerHeight * 0.2, towerWidth * 0.5, towerHeight * 0.18);

                // Rubble at base
                ctx.fillStyle = '#5A5A5A';
                // Left rubble pile
                ctx.beginPath();
                ctx.moveTo(pos.x - towerWidth * 0.6, pos.y + towerHeight * 0.35);
                ctx.lineTo(pos.x - towerWidth * 0.7, pos.y + towerHeight * 0.42);
                ctx.lineTo(pos.x - towerWidth * 0.4, pos.y + towerHeight * 0.42);
                ctx.closePath();
                ctx.fill();
                // Right rubble pile
                ctx.beginPath();
                ctx.moveTo(pos.x + towerWidth * 0.6, pos.y + towerHeight * 0.35);
                ctx.lineTo(pos.x + towerWidth * 0.7, pos.y + towerHeight * 0.42);
                ctx.lineTo(pos.x + towerWidth * 0.4, pos.y + towerHeight * 0.42);
                ctx.closePath();
                ctx.fill();

                // Overgrown vines/vegetation
                ctx.strokeStyle = '#556B2F';
                ctx.lineWidth = 2 * zoom;
                ctx.lineCap = 'round';
                // Left vine
                ctx.beginPath();
                ctx.moveTo(pos.x - towerWidth * 0.4, pos.y - towerHeight * 0.3);
                ctx.quadraticCurveTo(pos.x - towerWidth * 0.5, pos.y - towerHeight * 0.1, pos.x - towerWidth * 0.45, pos.y + towerHeight * 0.1);
                ctx.stroke();
                // Right vine
                ctx.beginPath();
                ctx.moveTo(pos.x + towerWidth * 0.35, pos.y - towerHeight * 0.2);
                ctx.quadraticCurveTo(pos.x + towerWidth * 0.5, pos.y, pos.x + towerWidth * 0.4, pos.y + towerHeight * 0.2);
                ctx.stroke();

                // Small leaves on vines
                ctx.fillStyle = '#6B8E23';
                ctx.beginPath();
                ctx.arc(pos.x - towerWidth * 0.45, pos.y - towerHeight * 0.15, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x + towerWidth * 0.42, pos.y - towerHeight * 0.05, size * 0.06, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            } else if (hex.building.name === 'Abandoned Castle') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Central keep (tallest tower in center)
                const keepWidth = size * 0.5;
                const keepHeight = size * 1.3;
                ctx.fillStyle = '#696969';
                ctx.fillRect(pos.x - keepWidth / 2, pos.y - keepHeight * 0.5, keepWidth, keepHeight);

                // Jagged broken top of keep
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.moveTo(pos.x - keepWidth / 2, pos.y - keepHeight * 0.5);
                ctx.lineTo(pos.x - keepWidth * 0.3, pos.y - keepHeight * 0.65);
                ctx.lineTo(pos.x - keepWidth * 0.1, pos.y - keepHeight * 0.55);
                ctx.lineTo(pos.x + keepWidth * 0.15, pos.y - keepHeight * 0.7);
                ctx.lineTo(pos.x + keepWidth * 0.35, pos.y - keepHeight * 0.58);
                ctx.lineTo(pos.x + keepWidth / 2, pos.y - keepHeight * 0.5);
                ctx.closePath();
                ctx.fill();

                // Left side tower
                const leftTowerWidth = size * 0.35;
                const leftTowerHeight = size * 0.9;
                ctx.fillStyle = '#5A5A5A';
                ctx.fillRect(pos.x - size * 0.7, pos.y - leftTowerHeight * 0.4, leftTowerWidth, leftTowerHeight);

                // Left tower broken top
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.7, pos.y - leftTowerHeight * 0.4);
                ctx.lineTo(pos.x - size * 0.55, pos.y - leftTowerHeight * 0.52);
                ctx.lineTo(pos.x - size * 0.42, pos.y - leftTowerHeight * 0.45);
                ctx.lineTo(pos.x - size * 0.35, pos.y - leftTowerHeight * 0.4);
                ctx.closePath();
                ctx.fill();

                // Right side tower
                const rightTowerWidth = size * 0.32;
                const rightTowerHeight = size * 0.75;
                ctx.fillStyle = '#5A5A5A';
                ctx.fillRect(pos.x + size * 0.38, pos.y - rightTowerHeight * 0.35, rightTowerWidth, rightTowerHeight);

                // Right tower broken top (more damaged)
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.38, pos.y - rightTowerHeight * 0.35);
                ctx.lineTo(pos.x + size * 0.48, pos.y - rightTowerHeight * 0.42);
                ctx.lineTo(pos.x + size * 0.62, pos.y - rightTowerHeight * 0.38);
                ctx.lineTo(pos.x + size * 0.7, pos.y - rightTowerHeight * 0.35);
                ctx.closePath();
                ctx.fill();

                // Connecting walls between towers
                ctx.fillStyle = '#606060';
                // Left wall (partially collapsed)
                ctx.fillRect(pos.x - size * 0.35, pos.y - size * 0.2, size * 0.1, size * 0.5);
                // Right wall
                ctx.fillRect(pos.x + size * 0.25, pos.y - size * 0.15, size * 0.13, size * 0.45);

                // Wall battlements (scattered, broken)
                ctx.fillStyle = '#707070';
                ctx.fillRect(pos.x - size * 0.33, pos.y - size * 0.23, size * 0.06, size * 0.08);
                ctx.fillRect(pos.x + size * 0.3, pos.y - size * 0.18, size * 0.05, size * 0.06);

                // Windows on keep
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(pos.x - keepWidth * 0.15, pos.y - keepHeight * 0.35, keepWidth * 0.12, keepHeight * 0.15);
                ctx.fillRect(pos.x - keepWidth * 0.15, pos.y - keepHeight * 0.1, keepWidth * 0.12, keepHeight * 0.15);
                ctx.fillRect(pos.x - keepWidth * 0.15, pos.y + keepHeight * 0.15, keepWidth * 0.12, keepHeight * 0.15);

                // Left tower window
                ctx.fillRect(pos.x - size * 0.58, pos.y - leftTowerHeight * 0.15, leftTowerWidth * 0.35, leftTowerHeight * 0.2);

                // Right tower window
                ctx.fillRect(pos.x + size * 0.48, pos.y - rightTowerHeight * 0.12, rightTowerWidth * 0.4, rightTowerHeight * 0.18);

                // Main gate (collapsed)
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(pos.x - keepWidth * 0.25, pos.y + keepHeight * 0.35, keepWidth * 0.5, keepHeight * 0.18);

                // Cracks throughout structure
                ctx.strokeStyle = '#2F2F2F';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                // Keep cracks
                ctx.moveTo(pos.x - keepWidth * 0.2, pos.y - keepHeight * 0.25);
                ctx.lineTo(pos.x - keepWidth * 0.15, pos.y + keepHeight * 0.1);
                ctx.moveTo(pos.x + keepWidth * 0.25, pos.y - keepHeight * 0.15);
                ctx.lineTo(pos.x + keepWidth * 0.3, pos.y + keepHeight * 0.2);
                // Left tower crack
                ctx.moveTo(pos.x - size * 0.5, pos.y - leftTowerHeight * 0.2);
                ctx.lineTo(pos.x - size * 0.52, pos.y + leftTowerHeight * 0.3);
                ctx.stroke();

                // Rubble piles at base
                ctx.fillStyle = '#4A4A4A';
                // Left rubble
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.75, pos.y + leftTowerHeight * 0.5);
                ctx.lineTo(pos.x - size * 0.85, pos.y + leftTowerHeight * 0.65);
                ctx.lineTo(pos.x - size * 0.55, pos.y + leftTowerHeight * 0.65);
                ctx.closePath();
                ctx.fill();
                // Right rubble
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.65, pos.y + rightTowerHeight * 0.55);
                ctx.lineTo(pos.x + size * 0.75, pos.y + rightTowerHeight * 0.7);
                ctx.lineTo(pos.x + size * 0.5, pos.y + rightTowerHeight * 0.7);
                ctx.closePath();
                ctx.fill();
                // Center rubble
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.15, pos.y + keepHeight * 0.48);
                ctx.lineTo(pos.x - size * 0.2, pos.y + keepHeight * 0.58);
                ctx.lineTo(pos.x + size * 0.1, pos.y + keepHeight * 0.58);
                ctx.closePath();
                ctx.fill();

                // Overgrown vines
                ctx.strokeStyle = '#3A5F0B';
                ctx.lineWidth = 2 * zoom;
                ctx.lineCap = 'round';
                // Left side vine
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.6, pos.y - leftTowerHeight * 0.3);
                ctx.quadraticCurveTo(pos.x - size * 0.7, pos.y, pos.x - size * 0.62, pos.y + leftTowerHeight * 0.4);
                ctx.stroke();
                // Keep vine
                ctx.beginPath();
                ctx.moveTo(pos.x - keepWidth * 0.35, pos.y - keepHeight * 0.3);
                ctx.quadraticCurveTo(pos.x - keepWidth * 0.5, pos.y, pos.x - keepWidth * 0.4, pos.y + keepHeight * 0.3);
                ctx.stroke();
                // Right side vine
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.5, pos.y - rightTowerHeight * 0.2);
                ctx.quadraticCurveTo(pos.x + size * 0.6, pos.y, pos.x + size * 0.52, pos.y + rightTowerHeight * 0.3);
                ctx.stroke();

                // Leaves on vines
                ctx.fillStyle = '#4A7023';
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.65, pos.y - leftTowerHeight * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x - keepWidth * 0.42, pos.y - keepHeight * 0.05, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.55, pos.y - rightTowerHeight * 0.05, size * 0.06, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            } else if (hex.building.name === 'Beast Den') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Rocky hillside/mound
                ctx.fillStyle = '#5A4A3A';
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y + size * 0.2, size * 0.7, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Darker rocky texture
                ctx.fillStyle = '#4A3A2A';
                ctx.beginPath();
                ctx.ellipse(pos.x - size * 0.2, pos.y + size * 0.15, size * 0.3, size * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pos.x + size * 0.25, pos.y + size * 0.1, size * 0.25, size * 0.18, 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Cave entrance (dark opening)
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                // Irregular cave mouth
                ctx.moveTo(pos.x - size * 0.35, pos.y);
                ctx.quadraticCurveTo(pos.x - size * 0.25, pos.y - size * 0.45, pos.x, pos.y - size * 0.5);
                ctx.quadraticCurveTo(pos.x + size * 0.25, pos.y - size * 0.45, pos.x + size * 0.35, pos.y);
                ctx.quadraticCurveTo(pos.x + size * 0.2, pos.y + size * 0.15, pos.x, pos.y + size * 0.18);
                ctx.quadraticCurveTo(pos.x - size * 0.2, pos.y + size * 0.15, pos.x - size * 0.35, pos.y);
                ctx.closePath();
                ctx.fill();

                // Inner shadow/depth
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y - size * 0.1, size * 0.2, size * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Rocky outcrops around entrance
                ctx.fillStyle = '#6B5A4A';
                // Left rock
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.45, pos.y + size * 0.05);
                ctx.lineTo(pos.x - size * 0.5, pos.y + size * 0.25);
                ctx.lineTo(pos.x - size * 0.3, pos.y + size * 0.2);
                ctx.closePath();
                ctx.fill();
                // Right rock
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.45, pos.y - size * 0.05);
                ctx.lineTo(pos.x + size * 0.5, pos.y + size * 0.2);
                ctx.lineTo(pos.x + size * 0.35, pos.y + size * 0.15);
                ctx.closePath();
                ctx.fill();
                // Top rock
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.1, pos.y - size * 0.55);
                ctx.lineTo(pos.x + size * 0.15, pos.y - size * 0.6);
                ctx.lineTo(pos.x + size * 0.25, pos.y - size * 0.45);
                ctx.lineTo(pos.x, pos.y - size * 0.48);
                ctx.closePath();
                ctx.fill();

                // Cracks in rocks
                ctx.strokeStyle = '#3A2A1A';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.4, pos.y - size * 0.1);
                ctx.lineTo(pos.x - size * 0.35, pos.y + size * 0.05);
                ctx.moveTo(pos.x + size * 0.15, pos.y - size * 0.5);
                ctx.lineTo(pos.x + size * 0.2, pos.y - size * 0.3);
                ctx.stroke();

                // Bones scattered around entrance
                ctx.strokeStyle = '#D8D8C8';
                ctx.lineCap = 'round';
                ctx.lineWidth = 1.2 * zoom;

                // Left bone
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.5, pos.y + size * 0.32);
                ctx.lineTo(pos.x - size * 0.42, pos.y + size * 0.36);
                ctx.stroke();
                // Bone ends
                ctx.fillStyle = '#D8D8C8';
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.5, pos.y + size * 0.32, size * 0.025, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.42, pos.y + size * 0.36, size * 0.025, 0, Math.PI * 2);
                ctx.fill();

                // Right bone (crossed)
                ctx.strokeStyle = '#D8D8C8';
                ctx.lineWidth = 1.2 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.4, pos.y + size * 0.28);
                ctx.lineTo(pos.x + size * 0.48, pos.y + size * 0.34);
                ctx.stroke();
                ctx.fillStyle = '#D8D8C8';
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.4, pos.y + size * 0.28, size * 0.025, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.48, pos.y + size * 0.34, size * 0.025, 0, Math.PI * 2);
                ctx.fill();

                // Small skull
                ctx.fillStyle = '#C8C8B8';
                ctx.beginPath();
                ctx.ellipse(pos.x - size * 0.15, pos.y + size * 0.35, size * 0.08, size * 0.07, 0, 0, Math.PI * 2);
                ctx.fill();
                // Eye sockets
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.18, pos.y + size * 0.34, size * 0.02, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.12, pos.y + size * 0.34, size * 0.02, 0, Math.PI * 2);
                ctx.fill();

                // Claw marks on rock face
                ctx.strokeStyle = 'rgba(40, 30, 20, 0.6)';
                ctx.lineWidth = 1.5 * zoom;
                ctx.lineCap = 'round';
                // Left claw marks (3 scratches)
                for (let i = 0; i < 3; i++) {
                    const offsetX = i * size * 0.05;
                    ctx.beginPath();
                    ctx.moveTo(pos.x - size * 0.5 + offsetX, pos.y - size * 0.25);
                    ctx.lineTo(pos.x - size * 0.45 + offsetX, pos.y - size * 0.05);
                    ctx.stroke();
                }
                // Right claw marks
                for (let i = 0; i < 3; i++) {
                    const offsetX = i * size * 0.05;
                    ctx.beginPath();
                    ctx.moveTo(pos.x + size * 0.3 + offsetX, pos.y - size * 0.3);
                    ctx.lineTo(pos.x + size * 0.35 + offsetX, pos.y - size * 0.1);
                    ctx.stroke();
                }

                ctx.restore();
            } else if (hex.building.name === 'Gold Mine') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Background mountain
                ctx.fillStyle = '#6B6B6B';
                ctx.beginPath();
                // Mountain peak
                ctx.moveTo(pos.x - size * 0.7, pos.y + size * 0.1);
                ctx.lineTo(pos.x - size * 0.1, pos.y - size * 0.8);
                ctx.lineTo(pos.x + size * 0.6, pos.y + size * 0.1);
                ctx.closePath();
                ctx.fill();

                // Mountain shadow/darker side
                ctx.fillStyle = '#555555';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.1, pos.y - size * 0.8);
                ctx.lineTo(pos.x + size * 0.6, pos.y + size * 0.1);
                ctx.lineTo(pos.x - size * 0.1, pos.y + size * 0.1);
                ctx.closePath();
                ctx.fill();

                // Snow cap on peak
                ctx.fillStyle = '#E8E8E8';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.25, pos.y - size * 0.6);
                ctx.lineTo(pos.x - size * 0.1, pos.y - size * 0.8);
                ctx.lineTo(pos.x + size * 0.05, pos.y - size * 0.6);
                ctx.closePath();
                ctx.fill();

                // Mountain rock texture
                ctx.strokeStyle = '#4A4A4A';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.5, pos.y - size * 0.3);
                ctx.lineTo(pos.x - size * 0.45, pos.y - size * 0.1);
                ctx.moveTo(pos.x + size * 0.1, pos.y - size * 0.4);
                ctx.lineTo(pos.x + size * 0.15, pos.y - size * 0.2);
                ctx.moveTo(pos.x + size * 0.35, pos.y - size * 0.15);
                ctx.lineTo(pos.x + size * 0.4, pos.y + size * 0.05);
                ctx.stroke();

                // Mine entrance tunnel (solid dark)
                ctx.fillStyle = '#050505';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.25, pos.y);
                ctx.lineTo(pos.x - size * 0.25, pos.y + size * 0.3);
                ctx.lineTo(pos.x + size * 0.25, pos.y + size * 0.3);
                ctx.lineTo(pos.x + size * 0.25, pos.y);
                ctx.lineTo(pos.x + size * 0.15, pos.y - size * 0.15);
                ctx.lineTo(pos.x - size * 0.15, pos.y - size * 0.15);
                ctx.closePath();
                ctx.fill();

                // Inner darkness (make it solid black)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.17, pos.y + size * 0.04);
                ctx.lineTo(pos.x - size * 0.17, pos.y + size * 0.3);
                ctx.lineTo(pos.x + size * 0.17, pos.y + size * 0.3);
                ctx.lineTo(pos.x + size * 0.17, pos.y + size * 0.04);
                ctx.lineTo(pos.x + size * 0.1, pos.y - size * 0.1);
                ctx.lineTo(pos.x - size * 0.1, pos.y - size * 0.1);
                ctx.closePath();
                ctx.fill();

                // Wooden support beams
                ctx.fillStyle = '#654321';
                // Left beam
                ctx.fillRect(pos.x - size * 0.23, pos.y, size * 0.06, size * 0.3);
                // Right beam
                ctx.fillRect(pos.x + size * 0.17, pos.y, size * 0.06, size * 0.3);
                // Top beam (horizontal)
                ctx.fillRect(pos.x - size * 0.23, pos.y - size * 0.02, size * 0.46, size * 0.06);

                // Wood texture/grain
                ctx.strokeStyle = '#4a2511';
                ctx.lineWidth = 1 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.21, pos.y + size * 0.1);
                ctx.lineTo(pos.x - size * 0.19, pos.y + size * 0.15);
                ctx.moveTo(pos.x + size * 0.19, pos.y + size * 0.12);
                ctx.lineTo(pos.x + size * 0.21, pos.y + size * 0.18);
                ctx.stroke();

                // Minecart tracks
                ctx.strokeStyle = '#3A3A3A';
                ctx.lineWidth = 2 * zoom;
                // Left rail
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.12, pos.y + size * 0.3);
                ctx.lineTo(pos.x - size * 0.08, pos.y + size * 0.45);
                ctx.stroke();
                // Right rail
                ctx.beginPath();
                ctx.moveTo(pos.x + size * 0.12, pos.y + size * 0.3);
                ctx.lineTo(pos.x + size * 0.08, pos.y + size * 0.45);
                ctx.stroke();
                // Ties
                ctx.lineWidth = 1.5 * zoom;
                for (let i = 0; i < 3; i++) {
                    const tieY = pos.y + size * 0.3 + (i * size * 0.08);
                    ctx.beginPath();
                    ctx.moveTo(pos.x - size * 0.14, tieY);
                    ctx.lineTo(pos.x + size * 0.14, tieY);
                    ctx.stroke();
                }

                // Minecart
                ctx.fillStyle = '#2F2F2F';
                const cartX = pos.x;
                const cartY = pos.y + size * 0.38;
                ctx.beginPath();
                // Cart body (trapezoid)
                ctx.moveTo(cartX - size * 0.1, cartY);
                ctx.lineTo(cartX - size * 0.08, cartY + size * 0.08);
                ctx.lineTo(cartX + size * 0.08, cartY + size * 0.08);
                ctx.lineTo(cartX + size * 0.1, cartY);
                ctx.closePath();
                ctx.fill();

                // Cart wheels
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(cartX - size * 0.06, cartY + size * 0.08, size * 0.03, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cartX + size * 0.06, cartY + size * 0.08, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Gold ore in cart with glow
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 6 * zoom;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(cartX - size * 0.04, cartY + size * 0.02, size * 0.04, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cartX + size * 0.03, cartY + size * 0.04, size * 0.035, 0, Math.PI * 2);
                ctx.fill();

                // Darker gold shading
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#DAA520';
                ctx.beginPath();
                ctx.arc(cartX, cartY + size * 0.05, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Gold nuggets scattered around
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 4 * zoom;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.3, pos.y + size * 0.35, size * 0.035, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#DAA520';
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.38, pos.y + size * 0.4, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            } else if (hex.building.name === 'Nature Grove') {
                const size = HEX_SIZE * zoom;

                ctx.save();

                // Vertical offset to move entire grove up
                const yOffset = -size * 0.25;

                // Ancient stone circle base
                ctx.strokeStyle = '#5A5A5A';
                ctx.lineWidth = 3 * zoom;
                ctx.setLineDash([]);

                // Standing stones around the grove
                const numStones = 6;
                const stoneRadius = size * 0.6;
                for (let i = 0; i < numStones; i++) {
                    const angle = (Math.PI * 2 / numStones) * i - Math.PI / 2;
                    const stoneX = pos.x + Math.cos(angle) * stoneRadius;
                    const stoneY = pos.y + yOffset + Math.sin(angle) * stoneRadius;

                    // Stone pillar (darker)
                    ctx.fillStyle = '#4A4A4A';
                    ctx.fillRect(stoneX - size * 0.05, stoneY - size * 0.15, size * 0.1, size * 0.3);

                    // Moss on stones (darker)
                    ctx.fillStyle = '#2A4015';
                    ctx.fillRect(stoneX - size * 0.05, stoneY + size * 0.08, size * 0.1, size * 0.07);
                }

                // Central ancient tree (main focal point)
                const trunkWidth = size * 0.25;
                const trunkHeight = size * 1.1;

                // Tree trunk (thick and gnarled - darker)
                ctx.fillStyle = '#3A2A1A';
                ctx.fillRect(pos.x - trunkWidth / 2, pos.y + yOffset - trunkHeight * 0.3, trunkWidth, trunkHeight);

                // Trunk texture (bark lines - darker)
                ctx.strokeStyle = '#2A1A0A';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(pos.x - trunkWidth * 0.3, pos.y + yOffset - trunkHeight * 0.2);
                ctx.lineTo(pos.x - trunkWidth * 0.25, pos.y + yOffset + trunkHeight * 0.5);
                ctx.moveTo(pos.x + trunkWidth * 0.2, pos.y + yOffset - trunkHeight * 0.15);
                ctx.lineTo(pos.x + trunkWidth * 0.15, pos.y + yOffset + trunkHeight * 0.6);
                ctx.stroke();

                // Tree roots spreading out (darker)
                ctx.strokeStyle = '#3A2A1A';
                ctx.lineWidth = 3 * zoom;
                ctx.lineCap = 'round';
                // Left root
                ctx.beginPath();
                ctx.moveTo(pos.x - trunkWidth * 0.4, pos.y + yOffset + trunkHeight * 0.7);
                ctx.quadraticCurveTo(pos.x - size * 0.3, pos.y + yOffset + trunkHeight * 0.75, pos.x - size * 0.45, pos.y + yOffset + trunkHeight * 0.8);
                ctx.stroke();
                // Right root
                ctx.beginPath();
                ctx.moveTo(pos.x + trunkWidth * 0.4, pos.y + yOffset + trunkHeight * 0.7);
                ctx.quadraticCurveTo(pos.x + size * 0.3, pos.y + yOffset + trunkHeight * 0.75, pos.x + size * 0.45, pos.y + yOffset + trunkHeight * 0.8);
                ctx.stroke();
                // Center root
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y + yOffset + trunkHeight * 0.75);
                ctx.lineTo(pos.x, pos.y + yOffset + trunkHeight * 0.85);
                ctx.stroke();

                // Canopy/foliage (large bushy crown - darker)
                ctx.fillStyle = '#1A3010';
                // Large main canopy
                ctx.beginPath();
                ctx.arc(pos.x, pos.y + yOffset - trunkHeight * 0.35, size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Additional foliage clusters (darker)
                ctx.fillStyle = '#254015';
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.3, pos.y + yOffset - trunkHeight * 0.25, size * 0.35, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.3, pos.y + yOffset - trunkHeight * 0.3, size * 0.38, 0, Math.PI * 2);
                ctx.fill();

                // Lighter highlights on foliage (darker)
                ctx.fillStyle = '#2D5016';
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.15, pos.y + yOffset - trunkHeight * 0.45, size * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.2, pos.y + yOffset - trunkHeight * 0.4, size * 0.22, 0, Math.PI * 2);
                ctx.fill();

                // Magical glowing runes on trunk
                ctx.shadowColor = '#7FFF00';
                ctx.shadowBlur = 8 * zoom;
                ctx.strokeStyle = '#7FFF00';
                ctx.lineWidth = 1.5 * zoom;
                ctx.lineCap = 'round';

                // Rune 1 (upper)
                ctx.beginPath();
                ctx.arc(pos.x, pos.y + yOffset - trunkHeight * 0.15, size * 0.06, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y + yOffset - trunkHeight * 0.15 - size * 0.06);
                ctx.lineTo(pos.x, pos.y + yOffset - trunkHeight * 0.15 + size * 0.06);
                ctx.stroke();

                // Rune 2 (lower)
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.05, pos.y + yOffset + trunkHeight * 0.15);
                ctx.lineTo(pos.x, pos.y + yOffset + trunkHeight * 0.1);
                ctx.lineTo(pos.x + size * 0.05, pos.y + yOffset + trunkHeight * 0.15);
                ctx.stroke();

                // Mystical leaves floating around
                ctx.shadowBlur = 4 * zoom;
                ctx.fillStyle = '#7FFF00';
                const leafPositions = [
                    { x: pos.x - size * 0.55, y: pos.y + yOffset - trunkHeight * 0.4 },
                    { x: pos.x + size * 0.5, y: pos.y + yOffset - trunkHeight * 0.5 },
                    { x: pos.x - size * 0.4, y: pos.y + yOffset - trunkHeight * 0.6 }
                ];
                leafPositions.forEach(leaf => {
                    ctx.beginPath();
                    // Leaf shape (pointed oval)
                    ctx.ellipse(leaf.x, leaf.y, size * 0.04, size * 0.07, Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Small mushrooms at base
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#CC4444';
                // Left mushroom cap
                ctx.beginPath();
                ctx.arc(pos.x - size * 0.35, pos.y + yOffset + trunkHeight * 0.65, size * 0.06, Math.PI, 0);
                ctx.fill();
                // Left mushroom stem
                ctx.fillStyle = '#C8C8B8';
                ctx.fillRect(pos.x - size * 0.36, pos.y + yOffset + trunkHeight * 0.65, size * 0.02, size * 0.08);

                // Right mushroom cap
                ctx.fillStyle = '#CC4444';
                ctx.beginPath();
                ctx.arc(pos.x + size * 0.3, pos.y + yOffset + trunkHeight * 0.68, size * 0.05, Math.PI, 0);
                ctx.fill();
                // Right mushroom stem
                ctx.fillStyle = '#C8C8B8';
                ctx.fillRect(pos.x + size * 0.29, pos.y + yOffset + trunkHeight * 0.68, size * 0.02, size * 0.07);

                // Small plants/grass at base (darker)
                ctx.strokeStyle = '#1A3008';
                ctx.lineWidth = 1.5 * zoom;
                ctx.lineCap = 'round';
                for (let i = 0; i < 5; i++) {
                    const grassX = pos.x - size * 0.2 + (i * size * 0.1);
                    const grassY = pos.y + yOffset + trunkHeight * 0.75;
                    ctx.beginPath();
                    ctx.moveTo(grassX, grassY);
                    ctx.lineTo(grassX + (Math.random() - 0.5) * size * 0.05, grassY - size * 0.08);
                    ctx.stroke();
                }

                ctx.restore();
            } else if (hex.building.name === 'Dock') {
                const size = HEX_SIZE * zoom;
                const dockYOffset = size * 0.3; // Move dock lower

                ctx.save();

                // Support posts (75% shorter)
                const postWidth = size * 0.1;
                const postHeight = size * 0.2; // Was 0.8, now 0.2 (75% shorter)
                ctx.fillStyle = '#654321';

                // Left post
                ctx.fillRect(pos.x - size * 0.6, pos.y + dockYOffset, postWidth, postHeight);
                // Center post
                ctx.fillRect(pos.x - size * 0.1, pos.y + dockYOffset, postWidth, postHeight);
                // Right post
                ctx.fillRect(pos.x + size * 0.4, pos.y + dockYOffset, postWidth, postHeight);

                // Wooden platform/deck
                const platformHeight = size * 0.15;
                ctx.fillStyle = '#8B6F47';
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = zoom * 0.5;
                ctx.fillRect(pos.x - size * 0.7, pos.y + dockYOffset - platformHeight / 2, size * 1.3, platformHeight);
                ctx.strokeRect(pos.x - size * 0.7, pos.y + dockYOffset - platformHeight / 2, size * 1.3, platformHeight);

                // Platform planks detail
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = zoom * 0.3;
                ctx.beginPath();
                ctx.moveTo(pos.x - size * 0.5, pos.y + dockYOffset - platformHeight / 2);
                ctx.lineTo(pos.x - size * 0.5, pos.y + dockYOffset + platformHeight / 2);
                ctx.moveTo(pos.x - size * 0.25, pos.y + dockYOffset - platformHeight / 2);
                ctx.lineTo(pos.x - size * 0.25, pos.y + dockYOffset + platformHeight / 2);
                ctx.moveTo(pos.x, pos.y + dockYOffset - platformHeight / 2);
                ctx.lineTo(pos.x, pos.y + dockYOffset + platformHeight / 2);
                ctx.moveTo(pos.x + size * 0.25, pos.y + dockYOffset - platformHeight / 2);
                ctx.lineTo(pos.x + size * 0.25, pos.y + dockYOffset + platformHeight / 2);
                ctx.stroke();

                // Storehouse building
                const storehouseWidth = size * 0.7;
                const storehouseHeight = size * 0.55;
                ctx.fillStyle = '#A0522D';
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = zoom * 0.8;
                ctx.fillRect(pos.x - storehouseWidth / 2, pos.y + dockYOffset - size * 0.6, storehouseWidth, storehouseHeight);
                ctx.strokeRect(pos.x - storehouseWidth / 2, pos.y + dockYOffset - size * 0.6, storehouseWidth, storehouseHeight);

                // Storehouse roof (fixed to be properly centered triangle)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.moveTo(pos.x - storehouseWidth * 0.55, pos.y + dockYOffset - size * 0.6);
                ctx.lineTo(pos.x, pos.y + dockYOffset - size * 0.85);
                ctx.lineTo(pos.x + storehouseWidth * 0.55, pos.y + dockYOffset - size * 0.6);
                ctx.closePath();
                ctx.fill();

                // Storehouse door
                const doorWidth = size * 0.175;
                const doorHeight = size * 0.2;
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(pos.x - doorWidth / 2, pos.y + dockYOffset - size * 0.25, doorWidth, doorHeight);

                // Storehouse window
                const windowSize = size * 0.125;
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(pos.x + storehouseWidth * 0.15, pos.y + dockYOffset - size * 0.45, windowSize, windowSize);

                // Wooden crates on platform
                const crateSize = size * 0.125;
                ctx.fillStyle = '#654321';
                ctx.globalAlpha = 0.7;
                ctx.fillRect(pos.x + size * 0.4, pos.y + dockYOffset - size * 0.15, crateSize, crateSize);
                ctx.globalAlpha = 0.5;
                ctx.fillRect(pos.x + size * 0.5, pos.y + dockYOffset - size * 0.2, crateSize, crateSize);
                ctx.globalAlpha = 1.0;

                ctx.restore();
            } else if (hex.building.name === 'Watchtower') {
                const size = HEX_SIZE * zoom;
                const scale = size / 30; // SVG viewBox is 40x40 (-20 to 20), so scale factor

                ctx.save();

                // Stone base platform
                ctx.fillStyle = '#5A5A5A';
                ctx.strokeStyle = '#3A3A3A';
                ctx.lineWidth = 0.5 * scale;
                ctx.fillRect(pos.x - 8 * scale, pos.y + 10 * scale, 16 * scale, 3 * scale);
                ctx.strokeRect(pos.x - 8 * scale, pos.y + 10 * scale, 16 * scale, 3 * scale);

                // Wooden tower structure
                ctx.fillStyle = '#6B4423';
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 1 * scale;
                ctx.fillRect(pos.x - 6 * scale, pos.y - 2 * scale, 12 * scale, 12 * scale);
                ctx.strokeRect(pos.x - 6 * scale, pos.y - 2 * scale, 12 * scale, 12 * scale);

                // Wooden planks detail
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 0.5 * scale;
                ctx.beginPath();
                ctx.moveTo(pos.x - 6 * scale, pos.y + 2 * scale);
                ctx.lineTo(pos.x + 6 * scale, pos.y + 2 * scale);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pos.x - 6 * scale, pos.y + 6 * scale);
                ctx.lineTo(pos.x + 6 * scale, pos.y + 6 * scale);
                ctx.stroke();

                // Observation platform
                ctx.fillStyle = '#8B6F47';
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 0.8 * scale;
                ctx.fillRect(pos.x - 7 * scale, pos.y - 4 * scale, 14 * scale, 2 * scale);
                ctx.strokeRect(pos.x - 7 * scale, pos.y - 4 * scale, 14 * scale, 2 * scale);

                // Wooden railings
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 1.2 * scale;
                ctx.beginPath();
                ctx.moveTo(pos.x - 7 * scale, pos.y - 3 * scale);
                ctx.lineTo(pos.x - 7 * scale, pos.y - 8 * scale);
                ctx.moveTo(pos.x - 3 * scale, pos.y - 3 * scale);
                ctx.lineTo(pos.x - 3 * scale, pos.y - 8 * scale);
                ctx.moveTo(pos.x + 3 * scale, pos.y - 3 * scale);
                ctx.lineTo(pos.x + 3 * scale, pos.y - 8 * scale);
                ctx.moveTo(pos.x + 7 * scale, pos.y - 3 * scale);
                ctx.lineTo(pos.x + 7 * scale, pos.y - 8 * scale);
                ctx.stroke();

                // Top railing
                ctx.beginPath();
                ctx.moveTo(pos.x - 7 * scale, pos.y - 8 * scale);
                ctx.lineTo(pos.x + 7 * scale, pos.y - 8 * scale);
                ctx.stroke();

                // Pointed roof
                ctx.fillStyle = '#654321';
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 0.8 * scale;
                ctx.beginPath();
                ctx.moveTo(pos.x - 8 * scale, pos.y - 8 * scale);
                ctx.lineTo(pos.x, pos.y - 16 * scale);
                ctx.lineTo(pos.x + 8 * scale, pos.y - 8 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Roof texture
                ctx.strokeStyle = '#4A2511';
                ctx.lineWidth = 0.5 * scale;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(pos.x - 4 * scale, pos.y - 12 * scale);
                ctx.lineTo(pos.x - 6 * scale, pos.y - 9 * scale);
                ctx.moveTo(pos.x + 4 * scale, pos.y - 12 * scale);
                ctx.lineTo(pos.x + 6 * scale, pos.y - 9 * scale);
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Draw fire/lit window when tower has enemies in view
                if (hex.owner === FACTIONS.PLAYER && hex.units.length > 0 && checkTowerHasEnemiesInView(hex)) {
                    ctx.fillStyle = '#FFA500';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - 6 * scale, 1.5 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }

                ctx.restore();
            } else {
                ctx.fillText(hex.building.symbol, pos.x, pos.y - 5 * zoom);
            }

            ctx.globalAlpha = previousAlpha;

            // Draw recruitment flag for buildings that can produce units
            if (hex.building.produces && hex.owner) {
                const flagSize = 6 * zoom;
                const flagX = pos.x - HEX_SIZE * zoom * 0.7;
                const flagY = pos.y + HEX_SIZE * zoom * 0.5;

                ctx.save();

                // Determine flag color based on faction
                let flagColor;
                if (hex.owner === FACTIONS.PLAYER) {
                    flagColor = '#44FF44';
                } else if (hex.owner === FACTIONS.ANCIENT) {
                    flagColor = '#9932CC';
                } else if (hex.owner === FACTIONS.BEAST) {
                    flagColor = '#FF8C00';
                } else if (hex.owner === FACTIONS.NATURE) {
                    flagColor = '#32CD32';
                }

                // Draw flag pole
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(flagX, flagY);
                ctx.lineTo(flagX, flagY - flagSize * 2);
                ctx.stroke();

                // Draw flag
                ctx.fillStyle = flagColor;
                ctx.beginPath();
                ctx.moveTo(flagX, flagY - flagSize * 2);
                ctx.lineTo(flagX + flagSize * 1.5, flagY - flagSize * 1.5);
                ctx.lineTo(flagX, flagY - flagSize);
                ctx.closePath();
                ctx.fill();

                // Add flag outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 0.5 * zoom;
                ctx.stroke();

                ctx.restore();
            }
        }
        
        // Draw map
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            animationTime = Date.now();
            
            // Handle initial zoom animation differently - linear interpolation over exactly 3 seconds
            if (game.initialZooming && game.initialZoomStartTime > 0) {
                const elapsed = animationTime - game.initialZoomStartTime;
                const progress = Math.min(elapsed / game.initialZoomDuration, 1.0);

                // Linear interpolation from start to target
                zoom = 0.6 + (targetZoom - 0.6) * progress;
                offsetX = 0 + (targetOffsetX - 0) * progress;
                offsetY = 0 + (targetOffsetY - 0) * progress;

                // Check if animation is complete
                if (progress >= 1.0) {
                    game.initialZooming = false;
                    zoom = targetZoom;
                    offsetX = targetOffsetX;
                    offsetY = targetOffsetY;

                    // Show welcome message
                    const welcomeMsg = document.getElementById('welcomeMessage');
                    welcomeMsg.classList.add('show');

                    // Fade out after 2 seconds
                    setTimeout(() => {
                        welcomeMsg.classList.remove('show');
                        welcomeMsg.classList.add('fade-out');
                    }, 2000);
                }
            } else {
                // Normal smoothed zoom/pan when not in initial animation
                const zoomDiff = targetZoom - zoom;
                if (Math.abs(zoomDiff) > 0.001) {
                    zoom += zoomDiff * ZOOM_SMOOTHING;
                } else {
                    zoom = targetZoom;
                }

                const offsetXDiff = targetOffsetX - offsetX;
                const offsetYDiff = targetOffsetY - offsetY;
                if (Math.abs(offsetXDiff) > 0.5 || Math.abs(offsetYDiff) > 0.5) {
                    offsetX += offsetXDiff * CAMERA_SMOOTHING;
                    offsetY += offsetYDiff * CAMERA_SMOOTHING;
                } else {
                    offsetX = targetOffsetX;
                    offsetY = targetOffsetY;
                }
            }
            
            hexMap.forEach(hex => {
                const pos = hexToPixel(hex.q, hex.r);
                
                const lightValue = calculateSunLight(hex.q, hex.r);
                let tileColor = applyLighting(hex.color, lightValue);

                if (hex.type === TILE_TYPES.SEA) {
                    // Apply wave effect
                    const waveBrightness = calculateWaveEffect(hex, animationTime);

                    const rgb = tileColor.match(/\d+/g);
                    const brightnessAdjust = Math.min(40, Math.max(-20, waveBrightness));
                    tileColor = `rgb(${Math.min(255, Math.max(0, parseInt(rgb[0]) + brightnessAdjust))},
                                    ${Math.min(255, Math.max(0, parseInt(rgb[1]) + brightnessAdjust + 5))},
                                    ${Math.min(255, Math.max(0, parseInt(rgb[2]) + brightnessAdjust + 10))})`;

                } else if (hex.type === TILE_TYPES.VOID) {
                    const swirlSpeed = 0.0008;
                    const swirlIntensity = 17.5;
                    
                    const centerX = 0;
                    const centerY = 0;
                    const distFromCenter = Math.sqrt(Math.pow(hex.q - centerX, 2) + Math.pow(hex.r - centerY, 2));
                    const angle = Math.atan2(hex.r - centerY, hex.q - centerX);
                    
                    const swirlValue = Math.sin(animationTime * swirlSpeed + angle * 2 - distFromCenter * 0.2) *
                                      Math.cos(animationTime * swirlSpeed * 0.5 + distFromCenter * 0.15);
                    
                    const rgb = tileColor.match(/\d+/g);
                    const brightnessAdjust = swirlValue * swirlIntensity;
                    tileColor = `rgb(${Math.min(255, Math.max(0, parseInt(rgb[0]) + brightnessAdjust + 3))},
                                    ${Math.min(255, Math.max(0, parseInt(rgb[1]) + brightnessAdjust))},
                                    ${Math.min(255, Math.max(0, parseInt(rgb[2]) + brightnessAdjust + 5))})`;
                } else if (hex.type === TILE_TYPES.LAND && lightValue > 0.5) {
                    // Apply godray effect only in sunlit areas
                    const godrayIntensity = calculateGodrayEffect(hex.q, hex.r, animationTime);

                    const rgb = tileColor.match(/\d+/g);
                    const r = parseInt(rgb[0]);
                    const g = parseInt(rgb[1]);
                    const b = parseInt(rgb[2]);

                    // Apply godray as brightness multiplier with warm tint
                    const newR = Math.min(255, r * godrayIntensity * 1.05);
                    const newG = Math.min(255, g * godrayIntensity * 1.02);
                    const newB = Math.min(255, b * godrayIntensity * 0.98);

                    tileColor = `rgb(${Math.round(newR)}, ${Math.round(newG)}, ${Math.round(newB)})`;
                }

                const hexKey = `${hex.q},${hex.r}`;
                const hasMoved = game.movedUnits.has(hexKey);
                
                if (hasMoved && hex.units.length > 0) {
                    const rgb = tileColor.match(/\d+/g);
                    tileColor = `rgb(${parseInt(rgb[0]) * 0.7}, ${parseInt(rgb[1]) * 0.7}, ${parseInt(rgb[2]) * 0.7})`;
                }
                
                drawHex(pos.x, pos.y, HEX_SIZE, tileColor);
            });
            
            drawFootprints();
            
            drawSkulls();
            
            if (game.selectedHex && game.selectedHex.units.length > 0 && 
                game.selectedHex.unitOrigins && game.selectedHex.unitOrigins.length > 0 && 
                game.selectionMode === 'unit') {
                const origin = game.selectedHex.unitOrigins[game.selectedHex.unitOrigins.length - 1];
                const originHex = hexMap.get(`${origin.q},${origin.r}`);
                if (originHex) {
                    const pos = hexToPixel(origin.q, origin.r);
                    
                    ctx.save();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3 * zoom;
                    ctx.setLineDash([5 * zoom, 5 * zoom]);
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 10 * zoom;
                    ctx.globalAlpha = 0.5;

                    // Use cached hex path
                    const hexPath = getHexPath(HEX_SIZE);
                    ctx.translate(pos.x, pos.y);
                    ctx.stroke(hexPath);

                    ctx.globalAlpha = 0.8;
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `bold ${Math.max(8, 10 * zoom)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.setLineDash([]);
                    ctx.fillText('ORIGIN', 0, -HEX_SIZE * zoom * 0.8);
                    
                    ctx.restore();
                }
            }
            
            // Third pass: Draw move indicators and planned paths
            hexMap.forEach(hex => {
                const pos = hexToPixel(hex.q, hex.r);
                const isValidMove = game.validMoves.some(move => move.q === hex.q && move.r === hex.r);
                
                if (isValidMove && game.selectedHex) {
                    const distance = getHexDistance(game.selectedHex.q, game.selectedHex.r, hex.q, hex.r);
                    let moveType = 'move';

                    // Check if this is embarking onto water
                    if (hex.type === TILE_TYPES.SEA && game.selectedHex.type === TILE_TYPES.LAND) {
                        moveType = 'embark';
                    }
                    // Check if this is disembarking onto land
                    else if (hex.type === TILE_TYPES.LAND && game.selectedHex.type === TILE_TYPES.SEA && game.selectedHex.ship) {
                        moveType = 'disembark';
                    }
                    // Check for ranged attack
                    else if (game.selectedHex.units.length > 0) {
                        const unitCounts = countUnitTypes(game.selectedHex.units);
                        const hasRangedUnits = unitCounts.archers > 0 || unitCounts.shamans > 0;
                        const isRangedDistance = distance > 1 && distance <= 3;
                        const isEnemyTarget = hex.owner && hex.owner !== FACTIONS.PLAYER && hex.units.length > 0;

                        if (hasRangedUnits && isRangedDistance && isEnemyTarget) {
                            moveType = 'ranged';
                        } else if (hex.owner && hex.owner !== FACTIONS.PLAYER && hex.units.length > 0) {
                            moveType = 'attack';
                        } else if (hex.owner === FACTIONS.PLAYER && hex.units.length > 0) {
                            moveType = 'merge';
                        }
                    }

                    drawMoveIndicator(pos, HEX_SIZE, moveType);
                }
                
                // Draw indicator for hexes with queued movements
                const hexKey = `${hex.q},${hex.r}`;
                if (game.plannedPaths.has(hexKey) && hex.owner === FACTIONS.PLAYER) {
                    ctx.save();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2 * zoom;
                    ctx.setLineDash([3 * zoom, 3 * zoom]);
                    ctx.globalAlpha = 0.6;

                    const pulseAmount = Math.sin(animationTime * 0.005) * 0.05 + 0.95;

                    // Use cached hex path with pulse scaling
                    const hexPath = getHexPath(HEX_SIZE);
                    ctx.translate(pos.x, pos.y);
                    ctx.scale(pulseAmount, pulseAmount);
                    ctx.stroke(hexPath);

                    // Draw small "Q" for queued
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `bold ${Math.max(8, 10 * zoom)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = 0.8;
                    ctx.fillText('Q', (HEX_SIZE * zoom * 0.7) / pulseAmount, (-HEX_SIZE * zoom * 0.7) / pulseAmount);
                    
                    ctx.restore();
                }
            });

            // Draw valid build locations in building placement mode
            if (game.buildingPlacementMode && game.validBuildLocations.length > 0) {
                game.validBuildLocations.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r);
                    const pulseAmount = Math.sin(animationTime * 0.004) * 0.1 + 0.9;

                    ctx.save();
                    ctx.globalAlpha = 0.5 * pulseAmount;
                    ctx.fillStyle = '#00FF00';

                    const hexPath = getHexPath(HEX_SIZE);
                    ctx.translate(pos.x, pos.y);
                    ctx.scale(1.1, 1.1);
                    ctx.fill(hexPath);

                    ctx.restore();

                    // Draw border
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2 * zoom;
                    ctx.globalAlpha = 0.8;

                    ctx.translate(pos.x, pos.y);
                    ctx.stroke(hexPath);

                    ctx.restore();
                });
            }

            // Draw planned path for selected unit
            if (game.selectedHex && game.selectionMode === 'unit' && game.selectedHex.owner === FACTIONS.PLAYER) {
                const hexKey = `${game.selectedHex.q},${game.selectedHex.r}`;
                const plannedPath = game.plannedPaths.get(hexKey);
                
                if (plannedPath && plannedPath.length > 0) {
                    plannedPath.forEach((waypoint, index) => {
                        const pos = hexToPixel(waypoint.hex.q, waypoint.hex.r);
                        
                        ctx.save();
                        ctx.globalAlpha = 0.6;
                        
                        // Draw arrow pole
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 3 * zoom;
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y - 10 * zoom);
                        ctx.lineTo(pos.x, pos.y - 25 * zoom);
                        ctx.stroke();
                        
                        // Draw arrow head
                        ctx.fillStyle = '#FF4444';
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y - 25 * zoom);
                        ctx.lineTo(pos.x + 12 * zoom, pos.y - 20 * zoom);
                        ctx.lineTo(pos.x, pos.y - 15 * zoom);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw turn number
                        ctx.globalAlpha = 0.9;
                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.font = `bold ${Math.max(10, 12 * zoom)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const turnText = `${waypoint.turn}`;
                        ctx.strokeText(turnText, pos.x, pos.y);
                        ctx.fillText(turnText, pos.x, pos.y);
                        
                        ctx.restore();
                        
                        // Draw connecting lines between waypoints
                        if (index < plannedPath.length - 1) {
                            const nextPos = hexToPixel(plannedPath[index + 1].hex.q, plannedPath[index + 1].hex.r);
                            ctx.save();
                            ctx.strokeStyle = '#FFD700';
                            ctx.lineWidth = 2 * zoom;
                            ctx.globalAlpha = 0.4;
                            ctx.setLineDash([5 * zoom, 5 * zoom]);
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                            ctx.lineTo(nextPos.x, nextPos.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    });
                }
            }
            
            // Draw all queued paths when Q is pressed
            if (game.showAllPaths) {
                game.plannedPaths.forEach((plannedPath, hexKey) => {
                    const hex = hexMap.get(hexKey);
                    if (!hex || hex === game.selectedHex) return; // Skip selected hex (already drawn above)
                    
                    if (plannedPath && plannedPath.length > 0) {
                        plannedPath.forEach((waypoint, index) => {
                            const pos = hexToPixel(waypoint.hex.q, waypoint.hex.r);
                            
                            ctx.save();
                            ctx.globalAlpha = 0.4;
                            
                            // Draw arrow pole
                            ctx.strokeStyle = '#44FF44';
                            ctx.lineWidth = 2 * zoom;
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y - 8 * zoom);
                            ctx.lineTo(pos.x, pos.y - 20 * zoom);
                            ctx.stroke();
                            
                            // Draw arrow head
                            ctx.fillStyle = '#44FF44';
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y - 20 * zoom);
                            ctx.lineTo(pos.x + 10 * zoom, pos.y - 16 * zoom);
                            ctx.lineTo(pos.x, pos.y - 12 * zoom);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Draw turn number
                            ctx.globalAlpha = 0.6;
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2;
                            ctx.font = `bold ${Math.max(8, 10 * zoom)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const turnText = `${waypoint.turn}`;
                            ctx.strokeText(turnText, pos.x, pos.y);
                            ctx.fillText(turnText, pos.x, pos.y);
                            
                            ctx.restore();
                            
                            // Draw connecting lines between waypoints
                            if (index < plannedPath.length - 1) {
                                const nextPos = hexToPixel(plannedPath[index + 1].hex.q, plannedPath[index + 1].hex.r);
                                ctx.save();
                                ctx.strokeStyle = '#44FF44';
                                ctx.lineWidth = 1.5 * zoom;
                                ctx.globalAlpha = 0.25;
                                ctx.setLineDash([4 * zoom, 4 * zoom]);
                                ctx.beginPath();
                                ctx.moveTo(pos.x, pos.y);
                                ctx.lineTo(nextPos.x, nextPos.y);
                                ctx.stroke();
                                ctx.restore();
                            }
                        });
                    }
                });
            }
            
            if (game.hoveredPath && game.hoveredPath.length > 0 && game.selectedHex && 
                game.selectionMode === 'unit' && game.selectedHex.owner === FACTIONS.PLAYER) {
                game.hoveredPath.forEach((waypoint, index) => {
                    const pos = hexToPixel(waypoint.hex.q, waypoint.hex.r);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#44FF44';

                    // Use cached hex path
                    const hexPath = getHexPath(HEX_SIZE);
                    ctx.translate(pos.x, pos.y);
                    ctx.fill(hexPath);

                    ctx.restore();
                });
            }
            
            hexMap.forEach(hex => {
                const pos = hexToPixel(hex.q, hex.r);

                // Calculate lighting for this hex
                const lightValue = calculateSunLight(hex.q, hex.r);

                // Apply lighting to buildings and units using globalAlpha
                const previousAlpha = ctx.globalAlpha;
                // Map lightValue (0.1-1) to alpha (0.3-1) for visibility
                const lightAlpha = 0.3 + (lightValue * 0.7);
                ctx.globalAlpha = lightAlpha;

                drawBuilding(hex);
                drawUnits(hex);

                // Draw ships on water tiles
                if (hex.type === TILE_TYPES.SEA) {
                    drawShip(hex);
                }

                // Restore alpha for UI elements
                ctx.globalAlpha = previousAlpha;

                const hexKey = `${hex.q},${hex.r}`;
                const hasMoved = game.movedUnits.has(hexKey);
                const hasPath = game.plannedPaths.has(hexKey);

                if (hasMoved && hex.units.length > 0 && hex.owner === FACTIONS.PLAYER) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = `bold ${Math.max(8, 10 * zoom)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('MOVED', pos.x, pos.y + HEX_SIZE * zoom * 0.6);
                }
                
                // Show indicator for units with queued paths
                if (hasPath && hex.units.length > 0 && hex.owner === FACTIONS.PLAYER) {
                    const path = game.plannedPaths.get(hexKey);
                    if (path && path.length > 0) {
                        const turns = path[path.length - 1].turn;
                        
                        // Draw a small flag indicator
                        ctx.save();
                        ctx.fillStyle = '#FFD700';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        
                        const flagX = pos.x + HEX_SIZE * zoom * 0.6;
                        const flagY = pos.y - HEX_SIZE * zoom * 0.6;
                        
                        // Flag pole
                        ctx.beginPath();
                        ctx.moveTo(flagX, flagY);
                        ctx.lineTo(flagX, flagY + 10 * zoom);
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        
                        // Flag
                        ctx.beginPath();
                        ctx.moveTo(flagX, flagY);
                        ctx.lineTo(flagX + 8 * zoom, flagY + 3 * zoom);
                        ctx.lineTo(flagX, flagY + 6 * zoom);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                        
                        // Turn number on flag
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${Math.max(6, 8 * zoom)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(turns, flagX + 4 * zoom, flagY + 3 * zoom);
                        
                        ctx.restore();
                    }
                }
            });
            
            if (game.selectedHex) {
                const pos = hexToPixel(game.selectedHex.q, game.selectedHex.r);
                drawSelectionIndicator(pos, HEX_SIZE, true);
            }

            // Update tower smoke detection and draw smoke particles
            updateTowerSmoke();
            updateAndDrawSmokeParticles();

            const sunDir = document.getElementById('sunDirection');
            if (sunDir) {
                let angle = -game.sunAngle;
                while (angle < 0) angle += Math.PI * 2;
                while (angle > Math.PI * 2) angle -= Math.PI * 2;
                
                const directions = ['East', 'Northeast', 'North', 'Northwest', 'West', 'Southwest', 'South', 'Southeast'];
                const index = Math.round((angle / (Math.PI * 2)) * 8) % 8;
                sunDir.textContent = directions[index];
            }
        }

        // Continuous animation loop for smooth godray effects
        function animateMap() {
            drawMap();
            requestAnimationFrame(animateMap);
        }
        
        // Create skulls when units die
        function createSkulls(hex, count) {
            for (let i = 0; i < count; i++) {
                game.skulls.push({
                    q: hex.q,
                    r: hex.r,
                    offsetX: (Math.random() - 0.5) * HEX_SIZE * 0.6,
                    offsetY: (Math.random() - 0.5) * HEX_SIZE * 0.6,
                    createdTurn: game.turn,
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Draw skulls
        function drawSkulls() {
            const currentTurn = game.turn;
            
            // Clean up old skulls (older than 25 turns)
            game.skulls = game.skulls.filter(skull => currentTurn - skull.createdTurn < 25);
            
            const viewportPadding = 50;
            const minX = -viewportPadding;
            const maxX = canvas.width + viewportPadding;
            const minY = -viewportPadding;
            const maxY = canvas.height + viewportPadding;
            
            game.skulls.forEach(skull => {
                const age = currentTurn - skull.createdTurn;
                // Fade from 1.0 to 0.0 over 25 turns
                const opacity = 1.0 - (age / 25);
                
                const pos = hexToPixel(skull.q, skull.r);
                const x = pos.x + skull.offsetX * zoom;
                const y = pos.y + skull.offsetY * zoom;
                
                // Skip if outside viewport
                if (x < minX || x > maxX || y < minY || y > maxY) {
                    return;
                }

                // Use cached skull sprite
                const zoomLevels = [0.5, 1.0, 1.5, 2.0, 3.0];
                const closestZoom = findClosestZoomLevel(zoom, zoomLevels);
                const rotationIndex = findClosestRotation(skull.rotation, 8);

                if (skullSprites[closestZoom] && skullSprites[closestZoom][rotationIndex]) {
                    const sprite = skullSprites[closestZoom][rotationIndex];
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.drawImage(sprite, x - sprite.width / 2, y - sprite.height / 2);
                    ctx.restore();
                } else {
                    // Fallback to direct drawing if cache miss
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(skull.rotation);
                    ctx.globalAlpha = opacity;
                    ctx.font = `${Math.max(2, 3 * zoom)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 1;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText('üíÄ', 0, 0);
                    ctx.restore();
                }
            });
        }
        
        // Create footprints
        function createFootprints(fromHex, toHex, unitCount, faction, unitType) {
            const pathHexes = [];
            const distance = getHexDistance(fromHex.q, fromHex.r, toHex.q, toHex.r);
            
            for (let i = 0; i <= distance; i++) {
                const t = distance > 0 ? i / distance : 0;
                const q = Math.round(fromHex.q + (toHex.q - fromHex.q) * t);
                const r = Math.round(fromHex.r + (toHex.r - fromHex.r) * t);
                pathHexes.push({ q, r });
            }
            
            const fromPos = hexToPixel(fromHex.q, fromHex.r);
            const toPos = hexToPixel(toHex.q, toHex.r);
            const moveAngle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
            const footprintAngle = moveAngle + Math.PI/2;
            
            const isQuadruped = (unitType === UNIT_TYPES.WOLF || unitType === UNIT_TYPES.BEAR);
            
            for (let pathIndex = 0; pathIndex < pathHexes.length; pathIndex++) {
                const hex = pathHexes[pathIndex];
                
                for (let unitIndex = 0; unitIndex < unitCount; unitIndex++) {
                    const formationWidth = Math.min(unitCount * 0.2, 0.8);
                    const lateralOffset = (unitIndex - (unitCount - 1) / 2) * (formationWidth / Math.max(1, unitCount - 1));
                    
                    const perpAngle = moveAngle + Math.PI/2;
                    const baseOffsetX = Math.cos(perpAngle) * lateralOffset * HEX_SIZE;
                    const baseOffsetY = Math.sin(perpAngle) * lateralOffset * HEX_SIZE;
                    
                    if (isQuadruped) {
                        const stepLength = 0.15 * HEX_SIZE;
                        const stepWidth = 0.08 * HEX_SIZE;
                        
                        for (let leg = 0; leg < 4; leg++) {
                            const isLeft = (leg % 2 === 0);
                            const isFront = (leg < 2);
                            
                            const alongBodyOffset = (isFront ? 1 : -1) * stepLength;
                            const sideOffset = (isLeft ? -1 : 1) * stepWidth;
                            
                            const alongX = Math.cos(moveAngle) * alongBodyOffset + Math.cos(perpAngle) * sideOffset;
                            const alongY = Math.sin(moveAngle) * alongBodyOffset + Math.sin(perpAngle) * sideOffset;
                            
                            const gaitOffset = ((pathIndex + leg) % 2) * 0.1 * HEX_SIZE;
                            
                            game.footprints.push({
                                q: hex.q,
                                r: hex.r,
                                offsetX: baseOffsetX + alongX + (Math.random() - 0.5) * 0.05 * HEX_SIZE,
                                offsetY: baseOffsetY + alongY + gaitOffset + (Math.random() - 0.5) * 0.05 * HEX_SIZE,
                                createdTurn: game.turn,
                                faction: faction,
                                rotation: footprintAngle + (Math.random() - 0.5) * 0.15
                            });
                        }
                    } else {
                        const stepWidth = 0.06 * HEX_SIZE;
                        
                        for (let foot = 0; foot < 2; foot++) {
                            const isLeft = (foot === 0);
                            
                            const sideOffset = (isLeft ? -1 : 1) * stepWidth;
                            const perpX = Math.cos(perpAngle) * sideOffset;
                            const perpY = Math.sin(perpAngle) * sideOffset;
                            
                            const stepOffset = ((pathIndex + foot) % 2) * 0.12 * HEX_SIZE;
                            const alongX = Math.cos(moveAngle) * stepOffset;
                            const alongY = Math.sin(moveAngle) * stepOffset;
                            
                            game.footprints.push({
                                q: hex.q,
                                r: hex.r,
                                offsetX: baseOffsetX + perpX + alongX + (Math.random() - 0.5) * 0.05 * HEX_SIZE,
                                offsetY: baseOffsetY + perpY + alongY + (Math.random() - 0.5) * 0.05 * HEX_SIZE,
                                createdTurn: game.turn,
                                faction: faction,
                                rotation: footprintAngle + (Math.random() - 0.5) * 0.15 + (isLeft ? -0.05 : 0.05)
                            });
                        }
                    }
                }
            }
        }
        
        // Draw footprints
        function drawFootprints() {
            if (zoom < 0.8) return;
            
            const currentTurn = game.turn;
            
            game.footprints = game.footprints.filter(fp => currentTurn - fp.createdTurn < 2);
            
            const viewportPadding = 50;
            const minX = -viewportPadding;
            const maxX = canvas.width + viewportPadding;
            const minY = -viewportPadding;
            const maxY = canvas.height + viewportPadding;
            
            game.footprints.forEach(footprint => {
                const age = currentTurn - footprint.createdTurn;
                const opacity = age === 0 ? 0.4 : (age === 1 ? 0.2 : 0.1);
                
                const pos = hexToPixel(footprint.q, footprint.r);
                const x = pos.x + footprint.offsetX * zoom;
                const y = pos.y + footprint.offsetY * zoom;
                
                if (x < minX || x > maxX || y < minY || y > maxY) {
                    return;
                }

                // Use cached footprint sprite
                const zoomLevels = [0.8, 1.0, 1.5, 2.0, 3.0];
                const closestZoom = findClosestZoomLevel(zoom, zoomLevels);
                const rotationIndex = findClosestRotation(footprint.rotation, 16);

                if (footprintSprites[closestZoom] && footprintSprites[closestZoom][rotationIndex]) {
                    const sprite = footprintSprites[closestZoom][rotationIndex];
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.drawImage(sprite, x - sprite.width / 2, y - sprite.height / 2);
                    ctx.restore();
                } else {
                    // Fallback to direct drawing if cache miss
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(footprint.rotation);
                    const color = 'rgba(100, 80, 60,';
                    ctx.fillStyle = color + opacity + ')';
                    const printSize = 2 * zoom;
                    ctx.beginPath();
                    ctx.ellipse(0, -printSize * 0.8, printSize * 0.6, printSize * 1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(0, printSize * 0.6, printSize * 0.5, printSize * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            });
        }
        
        // AI turn logic
        function executeAITurn(faction) {
            const aiHexes = [];
            hexMap.forEach(hex => {
                if (hex.owner === faction && hex.units.length > 0) {
                    const hexKey = `${hex.q},${hex.r}`;
                    if (!game.movedUnits.has(hexKey)) {
                        aiHexes.push(hex);
                    }
                }
            });
            
            if (aiHexes.length === 0) return;
            
            const interestingTiles = game.interestingTilesCache.get(faction) || [];
            
            aiHexes.forEach(unitHex => {
                const hexKey = `${unitHex.q},${unitHex.r}`;
                
                const isOccupyingBuilding = unitHex.building && 
                    (unitHex.building.resource === 'gold' || 
                     unitHex.building.supplyBonus > 0 ||
                     unitHex.building.faction === faction);
                
                if (isOccupyingBuilding) {
                    if (unitHex.units.length > OPTIMAL_GARRISON_SIZE) {
                        const excessUnits = unitHex.units.length - OPTIMAL_GARRISON_SIZE;
                        
                        const movingUnits = unitHex.units.splice(OPTIMAL_GARRISON_SIZE, excessUnits);
                        const tempHex = {
                            q: unitHex.q,
                            r: unitHex.r,
                            units: movingUnits,
                            owner: faction,
                            unitOrigins: unitHex.unitOrigins
                        };
                        
                        const target = findBestAITargetOptimized(tempHex, faction, interestingTiles);
                        
                        if (target) {
                            const neighbors = getNeighbors(unitHex.q, unitHex.r);
                            let bestMove = null;
                            let bestDistance = Infinity;
                            
                            for (let n of neighbors) {
                                const neighborHex = hexMap.get(`${n.q},${n.r}`);
                                
                                if (neighborHex && neighborHex.type === TILE_TYPES.LAND) {
                                    const distance = getHexDistance(n.q, n.r, target.q, target.r);
                                    
                                    if (neighborHex.units.length === 0 || 
                                        (neighborHex.owner === faction && neighborHex.units.length + movingUnits.length <= 9) ||
                                        (neighborHex.owner && neighborHex.owner !== faction)) {
                                        
                                        if (distance < bestDistance) {
                                            bestDistance = distance;
                                            bestMove = neighborHex;
                                        }
                                    }
                                }
                            }
                            
                            if (bestMove) {
                                const unitType = movingUnits[0];
                                
                                if (bestMove.units.length === 0) {
                                    bestMove.units = [...movingUnits];
                                    bestMove.owner = faction;
                                    bestMove.unitOrigins = unitHex.unitOrigins;
                                    createFootprints(unitHex, bestMove, movingUnits.length, faction, unitType);
                                } else if (bestMove.owner === faction) {
                                    bestMove.units = bestMove.units.concat(movingUnits);
                                    createFootprints(unitHex, bestMove, movingUnits.length, faction, unitType);
                                } else {
                                    // Combat with experience system
                                    const attackers = movingUnits;
                                    const defenders = bestMove.units;
                                    
                                    createFootprints(unitHex, bestMove, movingUnits.length, faction, unitType);
                                    
                                    // Count shamans for defense debuff
                                    const attackerCounts = countUnitTypes(attackers);
                                    
                                    // Calculate total combat power
                                    let attackPower = 0;
                                    let defensePower = 0;
                                    
                                    attackers.forEach(unit => {
                                        const power = (unit.attack || unit.baseAttack || 1) * (unit.hp || unit.baseHp || 1);
                                        attackPower += power;
                                    });
                                    
                                    defenders.forEach(unit => {
                                        const attack = (unit.attack || unit.baseAttack || 1);
                                        const hp = (unit.hp || unit.baseHp || 1);
                                        // Shamans reduce enemy effectiveness
                                        const effectiveAttack = Math.max(1, attack - attackerCounts.shamans * 0.5);
                                        const power = effectiveAttack * hp;
                                        defensePower += power;
                                    });
                                    
                                    const totalPower = attackPower + defensePower;
                                    const attackerWinChance = attackPower / totalPower;
                                    
                                    let attackerLosses = 0;
                                    let defenderLosses = 0;
                                    
                                    for (let i = 0; i < attackers.length; i++) {
                                        if (Math.random() > attackerWinChance) attackerLosses++;
                                    }
                                    for (let i = 0; i < defenders.length; i++) {
                                        if (Math.random() > (1 - attackerWinChance)) defenderLosses++;
                                    }
                                    
                                    if (attackerLosses === 0 && defenderLosses === 0) {
                                        if (Math.random() > 0.5) {
                                            attackerLosses = 1;
                                        } else {
                                            defenderLosses = 1;
                                        }
                                    }
                                    
                                    attackerLosses = Math.min(attackerLosses, attackers.length);
                                    defenderLosses = Math.min(defenderLosses, defenders.length);
                                    
                                    // Create skulls for killed units
                                    if (attackerLosses > 0) {
                                        createSkulls(unitHex, attackerLosses);
                                    }
                                    if (defenderLosses > 0) {
                                        createSkulls(bestMove, defenderLosses);
                                    }
                                    
                                    attackers.splice(0, attackerLosses);
                                    defenders.splice(0, defenderLosses);
                                    
                                    // Grant experience to survivors
                                    const attackersWon = defenders.length === 0 && attackers.length > 0;
                                    const defendersWon = attackers.length === 0 && defenders.length > 0;
                                    
                                    if (attackersWon) {
                                        attackers.forEach(unit => {
                                            unit.battlesWon = (unit.battlesWon || 0) + 1;
                                            if (unit.battlesWon % 3 === 0) {
                                                unit.rank = (unit.rank || 0) + 1;
                                                unit.hp = (unit.hp || unit.baseHp) + 1;
                                                unit.attack = (unit.attack || unit.baseAttack) + 1;
                                            }
                                        });
                                    } else if (defendersWon) {
                                        defenders.forEach(unit => {
                                            unit.battlesWon = (unit.battlesWon || 0) + 1;
                                            if (unit.battlesWon % 3 === 0) {
                                                unit.rank = (unit.rank || 0) + 1;
                                                unit.hp = (unit.hp || unit.baseHp) + 1;
                                                unit.attack = (unit.attack || unit.baseAttack) + 1;
                                            }
                                        });
                                    }
                                    
                                    if (bestMove.units.length === 0 && movingUnits.length > 0) {
                                        bestMove.units = [...movingUnits];
                                        bestMove.owner = faction;
                                        bestMove.unitOrigins = unitHex.unitOrigins;
                                    } else {
                                        unitHex.units = unitHex.units.concat(movingUnits);
                                    }
                                }
                            } else {
                                unitHex.units = unitHex.units.concat(movingUnits);
                            }
                        } else {
                            unitHex.units = unitHex.units.concat(movingUnits);
                        }
                    }
                    
                    game.movedUnits.add(hexKey);
                    
                } else {
                    const target = findBestAITargetOptimized(unitHex, faction, interestingTiles);
                    
                    if (target) {
                        const neighbors = getNeighbors(unitHex.q, unitHex.r);
                        let bestMove = null;
                        let bestDistance = Infinity;
                        
                        for (let n of neighbors) {
                            const neighborHex = hexMap.get(`${n.q},${n.r}`);
                            
                            if (neighborHex && neighborHex.type === TILE_TYPES.LAND) {
                                const distance = getHexDistance(n.q, n.r, target.q, target.r);
                                
                                if (neighborHex.units.length === 0 || 
                                    (neighborHex.owner === faction && neighborHex.units.length + unitHex.units.length <= 9) ||
                                    (neighborHex.owner && neighborHex.owner !== faction)) {
                                    
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestMove = neighborHex;
                                    }
                                }
                            }
                        }
                        
                        if (bestMove) {
                            moveUnits(unitHex, bestMove);
                        }
                    } else {
                        const neighbors = getNeighbors(unitHex.q, unitHex.r);
                        const validMoves = neighbors.filter(n => {
                            const hex = hexMap.get(`${n.q},${n.r}`);
                            return hex && hex.type === TILE_TYPES.LAND && 
                                   (hex.units.length === 0 || 
                                    (hex.owner === faction && hex.units.length + unitHex.units.length <= 9));
                        });
                        
                        if (validMoves.length > 0) {
                            const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                            const moveHex = hexMap.get(`${randomMove.q},${randomMove.r}`);
                            if (moveHex) {
                                moveUnits(unitHex, moveHex);
                            }
                        }
                    }
                }
            });
            
            aiRecruitUnits(faction);
        }
        
        // Find best target using pre-cached interesting tiles
        function findBestAITargetOptimized(fromHex, faction, interestingTiles) {
            let bestTarget = null;
            let bestScore = -Infinity;
            const maxSearchDistance = 30;
            
            let closestUnoccupiedBuilding = null;
            let closestBuildingDistance = Infinity;
            
            for (let item of interestingTiles) {
                const hex = item.hex;
                const distance = getHexDistance(fromHex.q, fromHex.r, hex.q, hex.r);
                
                if (distance > maxSearchDistance || distance === 0) continue;
                
                if (item.type === 'neutral_building' && !hex.owner && distance < closestBuildingDistance) {
                    closestUnoccupiedBuilding = hex;
                    closestBuildingDistance = distance;
                }
            }
            
            if (closestUnoccupiedBuilding && closestBuildingDistance <= 10) {
                return closestUnoccupiedBuilding;
            }
            
            for (let item of interestingTiles) {
                const hex = item.hex;
                const distance = getHexDistance(fromHex.q, fromHex.r, hex.q, hex.r);
                
                if (distance > maxSearchDistance || distance === 0) continue;
                
                let score = item.priority - distance * 15;
                
                if (item.type === 'enemy' && hex.units.length < fromHex.units.length) {
                    score += 300;
                }
                
                if (distance <= 3) {
                    score += 200;
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = hex;
                    
                    if (score > 900 && distance < 5) {
                        return bestTarget;
                    }
                }
            }
            
            if (!bestTarget && closestUnoccupiedBuilding) {
                return closestUnoccupiedBuilding;
            }
            
            if (bestScore < 200) {
                const nearbyRange = 10;
                for (let hex of game.landTilesCache) {
                    const distance = getHexDistance(fromHex.q, fromHex.r, hex.q, hex.r);
                    
                    if (distance > nearbyRange || distance === 0) continue;
                    if (hex.owner === faction) continue;
                    
                    const score = 150 - distance * 10;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = hex;
                    }
                }
            }
            
            return bestTarget;
        }
        
        // AI recruitment
        function aiRecruitUnits(faction) {
            const resources = game.aiResources[faction];
            if (!resources) return;
            
            const turnsSinceLastRecruitment = game.turn - game.aiRecruitmentCooldown[faction];
            if (turnsSinceLastRecruitment < AI_RECRUITMENT_COOLDOWN) {
                return;
            }
            
            const unitCost = 5;
            const totalCost = unitCost * AI_RECRUITMENT_BATCH_SIZE;
            
            if (resources.gold < totalCost) {
                return;
            }
            
            let currentUnits = 0;
            let maxSupply = 0;
            let productionBuildings = [];
            
            hexMap.forEach(hex => {
                if (hex.owner === faction) {
                    currentUnits += hex.units.length;
                    if (hex.building && hex.building.supplyBonus) {
                        maxSupply += hex.building.supplyBonus;
                    }
                    if (hex.building && hex.building.faction === faction && hex.building.produces) {
                        productionBuildings.push(hex);
                    }
                }
            });
            
            if (currentUnits >= maxSupply - AI_RECRUITMENT_BATCH_SIZE || productionBuildings.length === 0) {
                return;
            }
            
            let recruited = false;
            productionBuildings.sort((a, b) => a.units.length - b.units.length);
            
            for (let hex of productionBuildings) {
                if (hex.units.length <= 6) {
                    const baseUnitType = hex.building.produces;

                    for (let i = 0; i < AI_RECRUITMENT_BATCH_SIZE; i++) {
                        if (hex.units.length < 9 && currentUnits < maxSupply && resources.gold >= unitCost) {
                            let unitType = baseUnitType;

                            // 30% chance to spawn variant units from certain buildings
                            if (Math.random() < 0.3) {
                                if (hex.building.name === 'Beast Den' && unitType === UNIT_TYPES.WOLF) {
                                    unitType = UNIT_TYPES.BEAR;
                                } else if (hex.building.name === 'Nature Grove' && unitType === UNIT_TYPES.TREANT) {
                                    unitType = UNIT_TYPES.DEER;
                                } else if (hex.building.name === 'Ancient Ruin' && unitType === UNIT_TYPES.GOLEM) {
                                    unitType = UNIT_TYPES.ELEMENTAL;
                                }
                            }

                            hex.units.push(createUnit(unitType));
                            resources.gold -= unitCost;
                            currentUnits++;
                            recruited = true;
                        }
                    }
                    
                    if (recruited) {
                        game.aiRecruitmentCooldown[faction] = game.turn;
                        break;
                    }
                }
            }
        }
        
        // Helper function to count unit types in an army
        function countUnitTypes(units) {
            const counts = {
                archers: 0,
                shamans: 0,
                melee: 0,
                goblins: 0,
                wolves: 0,
                bears: 0,
                treants: 0,
                golems: 0,
                elementals: 0
            };

            units.forEach(unit => {
                if (unit.name === 'Goblin Archer') {
                    counts.archers++;
                } else if (unit.name === 'Goblin Shaman') {
                    counts.shamans++;
                } else if (unit.name === 'Goblin') {
                    counts.goblins++;
                    counts.melee++;
                } else if (unit.name === 'Wolf') {
                    counts.wolves++;
                    counts.melee++;
                } else if (unit.name === 'Bear') {
                    counts.bears++;
                    counts.melee++;
                } else if (unit.name === 'Treant') {
                    counts.treants++;
                    counts.melee++;
                } else if (unit.name === 'Stone Golem') {
                    counts.golems++;
                    counts.melee++;
                } else if (unit.name === 'Elemental') {
                    counts.elementals++;
                    counts.melee++;
                } else {
                    counts.melee++;
                }
            });

            return counts;
        }
        
        // Ranged attack function
        function rangedAttack(fromHex, toHex) {
            const distance = getHexDistance(fromHex.q, fromHex.r, toHex.q, toHex.r);
            
            if (distance > 3 || distance <= 1 || toHex.type !== TILE_TYPES.LAND) {
                return false;
            }
            
            if (toHex.owner === fromHex.owner) {
                return false; // Can't attack friendly units
            }
            
            if (toHex.units.length === 0) {
                return false; // No targets
            }
            
            const fromKey = `${fromHex.q},${fromHex.r}`;
            if (game.movedUnits.has(fromKey)) {
                return false;
            }
            
            const attackers = fromHex.units;
            const defenders = toHex.units;
            const unitCounts = countUnitTypes(attackers);
            
            // Must have archers or shamans to do ranged attack
            if (unitCounts.archers === 0 && unitCounts.shamans === 0) {
                return false;
            }
            
            // Calculate ranged attack power
            let rangedAttackPower = 0;
            let shamanDebuff = 0;
            
            attackers.forEach(unit => {
                if (unit.name === 'Goblin Archer') {
                    const power = (unit.attack || unit.baseAttack || 2);
                    rangedAttackPower += power;
                } else if (unit.name === 'Goblin Shaman') {
                    // Shamans reduce enemy defense instead of dealing damage
                    shamanDebuff += 1;
                }
            });
            
            // Calculate defender power (reduced by shamans)
            let defensePower = 0;
            defenders.forEach(unit => {
                const hp = (unit.hp || unit.baseHp || 1);
                const attack = (unit.attack || unit.baseAttack || 1);
                // Shamans reduce effective defense
                const effectiveAttack = Math.max(1, attack - shamanDebuff * 0.5);
                const power = effectiveAttack * hp;
                defensePower += power;
            });
            
            // Apply ranged damage (only defenders can be hurt in ranged combat)
            let defenderLosses = 0;
            
            if (rangedAttackPower > 0) {
                const totalPower = rangedAttackPower + defensePower;
                const attackerWinChance = rangedAttackPower / totalPower;
                
                // Each defender unit rolls for casualties
                for (let i = 0; i < defenders.length; i++) {
                    if (Math.random() > (1 - attackerWinChance)) {
                        defenderLosses++;
                    }
                }
                
                // Ensure at least some effect if there are shamans or archers
                if (defenderLosses === 0 && (unitCounts.archers > 0 || unitCounts.shamans > 0)) {
                    if (Math.random() < 0.3) { // 30% chance to cause at least 1 casualty
                        defenderLosses = 1;
                    }
                }
            }
            
            defenderLosses = Math.min(defenderLosses, defenders.length);
            
            // Create skulls for killed units
            if (defenderLosses > 0) {
                createSkulls(toHex, defenderLosses);
            }
            
            // Remove casualties
            defenders.splice(0, defenderLosses);
            
            // Grant experience to surviving archers and shamans
            if (defenderLosses > 0) {
                attackers.forEach(unit => {
                    if (unit.name === 'Goblin Archer' || unit.name === 'Goblin Shaman') {
                        unit.battlesWon = (unit.battlesWon || 0) + 1;
                        
                        if (unit.battlesWon % 3 === 0) {
                            unit.rank = (unit.rank || 0) + 1;
                            unit.hp = (unit.hp || unit.baseHp) + 1;
                            unit.attack = (unit.attack || unit.baseAttack) + 1;
                        }
                    }
                });
            }
            
            // If all defenders eliminated, check if hex becomes neutral
            if (defenders.length === 0) {
                if (!toHex.building || !toHex.building.faction || toHex.building.faction !== toHex.owner) {
                    toHex.owner = null;
                }
            }
            
            game.movedUnits.add(fromKey);
            return true;
        }
        
        // Move units
        function moveUnits(fromHex, toHex) {
            const distance = getHexDistance(fromHex.q, fromHex.r, toHex.q, toHex.r);
            const fromKey = `${fromHex.q},${fromHex.r}`;

            // Check if already moved
            if (game.movedUnits.has(fromKey)) {
                return false;
            }

            // Prevent entry into void
            if (toHex.type === TILE_TYPES.VOID) {
                return false;
            }

            // Handle different movement types
            // Land to water (embark)
            if (fromHex.type === TILE_TYPES.LAND && toHex.type === TILE_TYPES.SEA) {
                if (!fromHex.building || !fromHex.building.allowsNaval) {
                    return false;
                }
                if (distance > 1) return false; // Can only embark to adjacent water
                return embarkShip(fromHex, toHex);
            }

            // Water to water (sail)
            if (fromHex.type === TILE_TYPES.SEA && toHex.type === TILE_TYPES.SEA) {
                return moveShip(fromHex, toHex);
            }

            // Water to land (disembark)
            if (fromHex.type === TILE_TYPES.SEA && toHex.type === TILE_TYPES.LAND) {
                if (distance > 1) return false; // Can only disembark to adjacent land
                return disembarkShip(fromHex, toHex);
            }

            // Regular land to land movement
            if (distance > 3 || toHex.type !== TILE_TYPES.LAND) {
                return false;
            }
            
            const unitType = fromHex.units[0];
            
            if (toHex.units.length === 0) {
                toHex.units = [...fromHex.units];
                toHex.owner = fromHex.owner;
                toHex.unitOrigins = fromHex.unitOrigins || [{ q: fromHex.q, r: fromHex.r, turn: game.turn }];
                createFootprints(fromHex, toHex, fromHex.units.length, fromHex.owner, unitType);
                fromHex.units = [];
                
                if (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner) {
                    fromHex.owner = null;
                }
                
                game.movedUnits.add(`${toHex.q},${toHex.r}`);
                return true;
            }
            else if (toHex.owner === fromHex.owner) {
                const totalUnits = fromHex.units.length + toHex.units.length;
                if (totalUnits <= 9) {
                    toHex.units = toHex.units.concat(fromHex.units);
                    createFootprints(fromHex, toHex, fromHex.units.length, fromHex.owner, unitType);
                    fromHex.units = [];
                    
                    if (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner) {
                        fromHex.owner = null;
                    }
                    
                    game.movedUnits.add(`${toHex.q},${toHex.r}`);
                    return true;
                }
                return false;
            }
            else {
                // Combat with experience system
                const attackers = fromHex.units;
                const defenders = toHex.units;

                // Count unit types to determine if we need to split melee and ranged
                const attackerCounts = countUnitTypes(attackers);
                const defenderCounts = countUnitTypes(defenders);

                // Split attackers into melee and ranged
                const meleeUnits = [];
                const rangedUnits = [];

                attackers.forEach(unit => {
                    if (unit.name === 'Goblin Archer' || unit.name === 'Goblin Shaman') {
                        rangedUnits.push(unit);
                    } else {
                        meleeUnits.push(unit);
                    }
                });

                // For melee units attacking at distance > 1, they need to move adjacent to the target first
                let meleeAttackHex = fromHex; // Where melee units will attack from
                if (meleeUnits.length > 0 && distance > 1) {
                    // Find an adjacent hex to the target for melee units to move to
                    const neighbors = getNeighbors(toHex.q, toHex.r);
                    let bestNeighbor = null;
                    let bestDistance = Infinity;

                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.q},${neighbor.r}`;
                        const neighborHex = hexMap.get(neighborKey);

                        if (neighborHex && neighborHex.type === TILE_TYPES.LAND) {
                            const distFromStart = getHexDistance(fromHex.q, fromHex.r, neighbor.q, neighbor.r);
                            // Prefer empty hexes or player-owned hexes that are closest to our starting position
                            if (distFromStart <= 3 && (!neighborHex.units || neighborHex.units.length === 0 || neighborHex.owner === fromHex.owner)) {
                                if (distFromStart < bestDistance) {
                                    bestDistance = distFromStart;
                                    bestNeighbor = neighborHex;
                                }
                            }
                        }
                    }

                    // If we found a good adjacent hex, move melee units there first
                    if (bestNeighbor && bestDistance <= 3) {
                        // Move melee units to the adjacent hex
                        if (bestNeighbor !== fromHex) {
                            if (bestNeighbor.units.length === 0 || bestNeighbor.owner === fromHex.owner) {
                                meleeAttackHex = bestNeighbor;
                                createFootprints(fromHex, meleeAttackHex, meleeUnits.length, fromHex.owner, meleeUnits[0]);
                                meleeAttackHex.units = meleeAttackHex.units.concat(meleeUnits);
                                meleeAttackHex.owner = fromHex.owner;

                                // Remove melee units from source, leave ranged units
                                fromHex.units = [...rangedUnits];
                                if (rangedUnits.length === 0 && (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner)) {
                                    fromHex.owner = null;
                                }
                            } else {
                                // The hex is not suitable for moving into
                                return false;
                            }
                        } else {
                            // bestNeighbor is the same as fromHex (already adjacent)
                            meleeAttackHex = fromHex;
                        }
                    } else {
                        // Can't find a valid adjacent hex for melee units
                        return false;
                    }
                } else if (meleeUnits.length > 0 && distance === 1) {
                    // Already adjacent, create footprints showing the attack movement
                    createFootprints(fromHex, toHex, meleeUnits.length, fromHex.owner, meleeUnits[0]);
                }

                // Calculate total combat power (all attackers participate)
                let attackPower = 0;
                let defensePower = 0;

                // All attackers deal damage, shamans reduce defender effectiveness
                attackers.forEach(unit => {
                    const attack = (unit.attack || unit.baseAttack || 1);
                    const hp = (unit.hp || unit.baseHp || 1);
                    const power = attack * hp;
                    attackPower += power;
                });

                // Defenders' power is reduced by attacking shamans
                defenders.forEach(unit => {
                    const attack = (unit.attack || unit.baseAttack || 1);
                    const hp = (unit.hp || unit.baseHp || 1);
                    // Shamans reduce enemy effectiveness
                    const effectiveAttack = Math.max(1, attack - attackerCounts.shamans * 0.5);
                    const power = effectiveAttack * hp;
                    defensePower += power;
                });

                // Determine casualties based on power ratio
                const totalPower = attackPower + defensePower;
                const attackerWinChance = attackPower / totalPower;

                let meleeAttackerLosses = 0;
                let rangedAttackerLosses = 0;
                let defenderLosses = 0;

                // Melee units take most of the casualties (80% chance)
                // Ranged units are safer (20% chance)
                for (let i = 0; i < meleeUnits.length; i++) {
                    if (Math.random() > attackerWinChance * 1.2) { // Slightly more dangerous for melee
                        meleeAttackerLosses++;
                    }
                }

                for (let i = 0; i < rangedUnits.length; i++) {
                    if (Math.random() > attackerWinChance * 0.3) { // Much safer for ranged
                        rangedAttackerLosses++;
                    }
                }

                for (let i = 0; i < defenders.length; i++) {
                    if (Math.random() > (1 - attackerWinChance)) {
                        defenderLosses++;
                    }
                }

                // Ensure at least some casualties if there's combat
                const totalAttackerLosses = meleeAttackerLosses + rangedAttackerLosses;
                if (totalAttackerLosses === 0 && defenderLosses === 0) {
                    if (Math.random() > 0.5) {
                        // Prefer melee casualties
                        if (meleeUnits.length > 0) {
                            meleeAttackerLosses = 1;
                        } else {
                            rangedAttackerLosses = 1;
                        }
                    } else {
                        defenderLosses = 1;
                    }
                }

                meleeAttackerLosses = Math.min(meleeAttackerLosses, meleeUnits.length);
                rangedAttackerLosses = Math.min(rangedAttackerLosses, rangedUnits.length);
                defenderLosses = Math.min(defenderLosses, defenders.length);

                // Create skulls for killed units
                if (meleeAttackerLosses > 0) {
                    createSkulls(meleeAttackHex, meleeAttackerLosses); // Melee dies at their attack position
                }
                if (rangedAttackerLosses > 0) {
                    createSkulls(fromHex, rangedAttackerLosses); // Ranged dies at original position
                }
                if (defenderLosses > 0) {
                    createSkulls(toHex, defenderLosses);
                }

                // Remove casualties from respective arrays
                meleeUnits.splice(0, meleeAttackerLosses);
                rangedUnits.splice(0, rangedAttackerLosses);
                defenders.splice(0, defenderLosses);

                // Combine survivors
                const survivingAttackers = [...meleeUnits, ...rangedUnits];

                // Grant experience to survivors
                const attackersWon = defenders.length === 0 && survivingAttackers.length > 0;
                const defendersWon = survivingAttackers.length === 0 && defenders.length > 0;

                if (attackersWon) {
                    survivingAttackers.forEach(unit => {
                        unit.battlesWon = (unit.battlesWon || 0) + 1;

                        // Rank up every 3 battles
                        if (unit.battlesWon % 3 === 0) {
                            unit.rank = (unit.rank || 0) + 1;
                            // Increase stats
                            unit.hp = (unit.hp || unit.baseHp) + 1;
                            unit.attack = (unit.attack || unit.baseAttack) + 1;
                        }
                    });
                } else if (defendersWon) {
                    defenders.forEach(unit => {
                        unit.battlesWon = (unit.battlesWon || 0) + 1;

                        // Rank up every 3 battles
                        if (unit.battlesWon % 3 === 0) {
                            unit.rank = (unit.rank || 0) + 1;
                            // Increase stats
                            unit.hp = (unit.hp || unit.baseHp) + 1;
                            unit.attack = (unit.attack || unit.baseAttack) + 1;
                        }
                    });
                }

                // Update hex ownership based on outcome
                if (defenders.length === 0 && meleeUnits.length > 0) {
                    // Melee units won, they occupy the hex
                    // Clear melee units from their attack position (if they moved to an intermediate hex)
                    if (meleeAttackHex !== fromHex && meleeAttackHex !== toHex) {
                        const meleeUnitSet = new Set(meleeUnits);
                        meleeAttackHex.units = meleeAttackHex.units.filter(u => !meleeUnitSet.has(u));
                        if (meleeAttackHex.units.length === 0 && (!meleeAttackHex.building || !meleeAttackHex.building.faction || meleeAttackHex.building.faction !== meleeAttackHex.owner)) {
                            meleeAttackHex.owner = null;
                        }
                    }

                    toHex.units = [...meleeUnits];
                    toHex.owner = fromHex.owner;
                    toHex.unitOrigins = fromHex.unitOrigins || [{ q: fromHex.q, r: fromHex.r, turn: game.turn }];

                    // Ranged units stay at original position
                    if (meleeAttackHex === fromHex) {
                        fromHex.units = [...rangedUnits];
                    }

                    // Update ownership of source hex
                    if (fromHex.units.length === 0 || (rangedUnits.length === 0 && meleeAttackHex === fromHex)) {
                        if (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner) {
                            fromHex.owner = null;
                        }
                    }

                    // Mark hexes as moved
                    game.movedUnits.add(`${toHex.q},${toHex.r}`);
                    if (meleeAttackHex !== fromHex && meleeAttackHex !== toHex) {
                        game.movedUnits.add(`${meleeAttackHex.q},${meleeAttackHex.r}`);
                    }
                    if (rangedUnits.length > 0) {
                        game.movedUnits.add(fromKey);
                    }
                    return true;
                } else if (defenders.length === 0 && meleeUnits.length === 0 && rangedUnits.length > 0) {
                    // Only ranged units survived, they don't move but clear the hex
                    if (!toHex.building || !toHex.building.faction || toHex.building.faction !== toHex.owner) {
                        toHex.owner = null;
                    }

                    game.movedUnits.add(fromKey);
                    return false;
                } else {
                    // Attackers lost or stalemate - units stay where they are
                    if (meleeAttackHex === fromHex) {
                        // Both melee and ranged at same location
                        fromHex.units = [...survivingAttackers];
                    } else {
                        // Melee at different location from ranged
                        meleeAttackHex.units = [...meleeUnits];
                        fromHex.units = [...rangedUnits];
                    }

                    // Update ownership
                    if (fromHex.units.length === 0) {
                        if (!fromHex.building || !fromHex.building.faction || fromHex.building.faction !== fromHex.owner) {
                            fromHex.owner = null;
                        }
                    }
                    if (meleeAttackHex !== fromHex && meleeAttackHex.units.length === 0) {
                        if (!meleeAttackHex.building || !meleeAttackHex.building.faction || meleeAttackHex.building.faction !== meleeAttackHex.owner) {
                            meleeAttackHex.owner = null;
                        }
                    }

                    game.movedUnits.add(fromKey);
                    if (meleeAttackHex !== fromHex) {
                        game.movedUnits.add(`${meleeAttackHex.q},${meleeAttackHex.r}`);
                    }
                    return false;
                }
            }
        }
        
        // Process buildings
        function processBuildings() {
            hexMap.forEach(hex => {
                if (hex.building && hex.owner) {
                    if (hex.building.baseIncome) {
                        if (hex.owner === FACTIONS.PLAYER) {
                            game.resources.gold += hex.building.baseIncome.gold || 0;
                        } else {
                            if (game.aiResources[hex.owner]) {
                                game.aiResources[hex.owner].gold += hex.building.baseIncome.gold || 0;
                            }
                        }
                    }
                    
                    if (hex.building.resource && hex.units.length > 0) {
                        if (hex.owner === FACTIONS.PLAYER) {
                            game.resources.gold += hex.building.amount || 0;
                        } else {
                            if (game.aiResources[hex.owner]) {
                                game.aiResources[hex.owner].gold += hex.building.amount || 0;
                            }
                        }
                    }
                }
            });
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('turnInfo').textContent = `Turn: ${game.turn}`;
            document.getElementById('goldAmount').textContent = game.resources.gold;
            
            let currentUnits = 0;
            let maxSupply = 0;
            
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER) {
                    currentUnits += hex.units.length;
                    if (hex.building && hex.building.supplyBonus) {
                        maxSupply += hex.building.supplyBonus;
                    }
                }
            });
            
            game.unitLimit.current = currentUnits;
            game.unitLimit.max = maxSupply;
            
            document.getElementById('unitsCount').textContent = `${currentUnits}/${maxSupply}`;
            
            // Update queue info
            const queuedCount = game.plannedPaths.size;
            const queueInfo = document.getElementById('queueInfo');
            if (queuedCount > 0) {
                queueInfo.textContent = `‚ö° ${queuedCount} queued movement${queuedCount > 1 ? 's' : ''} | `;
            } else {
                queueInfo.textContent = '';
            }
            
            updateUnitSelectionButtons();
            updateUnitButtonStates();
            updateActionButtonStates();
            updateBuildingButtonStates();
            updateLeaderboard();
        }

        // Update action button states based on requirements
        function updateActionButtonStates() {
            const upgradeBtn = document.getElementById('upgradeBtn');
            const splitBtn = document.getElementById('splitBtn');
            const endTurnBtn = document.getElementById('endTurnBtn');
            const recruitmentPanel = document.getElementById('recruitmentPanel');

            // Helper function to clear all state classes
            function clearStateClasses(btn) {
                btn.classList.remove('can-act', 'cannot-act', 'greyed-out', 'no-resources', 'has-idle-units');
            }

            // ===== RECRUITMENT PANEL =====
            // Check if a recruitment building is selected
            const hasRecruitmentBuildingSelected = game.selectedHex &&
                game.selectedHex.owner === FACTIONS.PLAYER &&
                game.selectedHex.building &&
                game.selectionMode === 'building';

            if (!hasRecruitmentBuildingSelected) {
                // Grey out the panel if no recruitment building selected
                recruitmentPanel.classList.add('greyed-out');
            } else {
                // Remove grey from panel
                recruitmentPanel.classList.remove('greyed-out');
            }

            // ===== UPGRADE BUTTON =====
            clearStateClasses(upgradeBtn);

            let canUpgrade = false;
            let showUpgradeBtn = false;
            if (game.selectedHex && game.selectedHex.owner === FACTIONS.PLAYER &&
                game.selectedHex.building && game.selectionMode === 'building') {
                const building = game.selectedHex.building;
                if (building.upgradeTo && building.upgradeCost) {
                    showUpgradeBtn = true;
                    canUpgrade = game.resources.gold >= building.upgradeCost.gold;
                    upgradeBtn.textContent = `‚¨ÜÔ∏è Upgrade Building (${building.upgradeCost.gold}g)`;
                }
            }

            if (showUpgradeBtn) {
                upgradeBtn.style.display = '';
                if (canUpgrade) {
                    upgradeBtn.classList.add('can-act');
                } else {
                    upgradeBtn.classList.add('cannot-act');
                }
            } else {
                upgradeBtn.style.display = 'none';
            }

            // ===== SPLIT BUTTON =====
            clearStateClasses(splitBtn);

            const hasArmySelected = game.selectedHex &&
                game.selectedHex.owner === FACTIONS.PLAYER &&
                game.selectedHex.units.length > 0 &&
                game.selectionMode === 'unit';

            if (!hasArmySelected) {
                // Grey out if no army selected
                splitBtn.classList.add('greyed-out');
            } else {
                // Check if can split
                let canSplit = false;
                const hexKey = `${game.selectedHex.q},${game.selectedHex.r}`;
                const hasEnoughUnits = game.selectedHex.units.length >= 2;
                const hasntMoved = !game.movedUnits.has(hexKey);

                if (hasEnoughUnits && hasntMoved) {
                    const neighbors = getNeighbors(game.selectedHex.q, game.selectedHex.r);
                    const splitSize = Math.floor(game.selectedHex.units.length / 2);
                    const hasValidTarget = neighbors.some(n => {
                        const hex = hexMap.get(`${n.q},${n.r}`);
                        if (!hex || hex.type !== TILE_TYPES.LAND) return false;
                        if (hex.units.length === 0) return true;
                        if (hex.owner === FACTIONS.PLAYER && hex.units.length + splitSize <= 9) return true;
                        return false;
                    });

                    canSplit = hasValidTarget;
                }

                if (canSplit) {
                    splitBtn.classList.add('can-act');
                } else {
                    splitBtn.classList.add('cannot-act');
                }
            }

            // ===== END TURN BUTTON =====
            clearStateClasses(endTurnBtn);

            // Check if player has unmoved units not on buildings
            let hasIdleUnits = false;
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER && hex.units.length > 0) {
                    const hexKey = `${hex.q},${hex.r}`;
                    const hasMoved = game.movedUnits.has(hexKey);
                    const isOnBuilding = hex.building !== null;

                    if (!hasMoved && !isOnBuilding) {
                        hasIdleUnits = true;
                    }
                }
            });

            if (hasIdleUnits) {
                endTurnBtn.classList.add('has-idle-units');
            } else {
                endTurnBtn.classList.add('can-act');
            }
        }

        // Update building button states
        function updateBuildingButtonStates() {
            const buildFortBtn = document.getElementById('buildFortBtn');
            const buildTowerBtn = document.getElementById('buildTowerBtn');
            const buildFarmBtn = document.getElementById('buildFarmBtn');
            const buildDockBtn = document.getElementById('buildDockBtn');

            const buildingCosts = {
                'FORT': 125,
                'TOWER': 75,
                'FARM': 100,
                'DOCK': 150
            };

            // Helper function to clear all state classes
            function clearStateClasses(btn) {
                btn.classList.remove('can-act', 'cannot-act', 'greyed-out');
            }

            // Update each button based on gold availability
            [
                { btn: buildFortBtn, type: 'FORT' },
                { btn: buildTowerBtn, type: 'TOWER' },
                { btn: buildFarmBtn, type: 'FARM' },
                { btn: buildDockBtn, type: 'DOCK' }
            ].forEach(({ btn, type }) => {
                clearStateClasses(btn);

                const cost = buildingCosts[type];
                if (game.resources.gold >= cost) {
                    btn.classList.add('can-act');
                } else {
                    btn.classList.add('greyed-out');
                }
            });
        }

        // Update leaderboard
        function updateLeaderboard() {
            const factionStats = {};
            
            [FACTIONS.PLAYER, FACTIONS.ANCIENT, FACTIONS.BEAST, FACTIONS.NATURE].forEach(faction => {
                factionStats[faction] = {
                    units: 0,
                    gold: faction === FACTIONS.PLAYER ? game.resources.gold : (game.aiResources[faction] ? game.aiResources[faction].gold : 0),
                    buildings: 0,
                    maxSupply: 0
                };
            });
            
            hexMap.forEach(hex => {
                if (hex.owner && factionStats[hex.owner]) {
                    factionStats[hex.owner].units += hex.units.length;
                    if (hex.building) {
                        factionStats[hex.owner].buildings++;
                        if (hex.building.supplyBonus) {
                            factionStats[hex.owner].maxSupply += hex.building.supplyBonus;
                        }
                    }
                }
            });
            
            const sortedFactions = Object.entries(factionStats).sort((a, b) => {
                if (b[1].units !== a[1].units) return b[1].units - a[1].units;
                if (b[1].buildings !== a[1].buildings) return b[1].buildings - a[1].buildings;
                return b[1].gold - a[1].gold;
            });
            
            const leaderboardContent = document.getElementById('leaderboardContent');
            leaderboardContent.innerHTML = sortedFactions.map(([faction, stats]) => {
                const factionName = faction.charAt(0).toUpperCase() + faction.slice(1);
                const className = `faction-${faction}`;
                return `
                    <div class="faction-row">
                        <span class="${className} faction-name">${factionName}</span>
                        <div class="faction-stats">
                            <span class="faction-units">‚öîÔ∏è${stats.units}/${stats.maxSupply}</span>
                            <span class="faction-gold">üí∞${stats.gold}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Select unit type
        function selectUnitType(unitType) {
            const hasFortress = playerHasFortress();

            // Check if trying to select a locked unit
            if ((unitType === 'archer' || unitType === 'shaman') && !hasFortress) {
                selectedInfo.textContent = 'üîí This unit requires a Goblin Fortress! Upgrade your camp first (30g).';
                return;
            }

            game.selectedUnitType = unitType;
            updateUnitSelectionButtons();
            updateActionButtonStates();

            // Directly recruit units when clicking on the unit type
            recruitUnits();
        }
        
        // Update unit selection buttons
        function updateUnitSelectionButtons() {
            document.getElementById('goblinBtn').classList.remove('selected');
            document.getElementById('archerBtn').classList.remove('selected');
            document.getElementById('shamanBtn').classList.remove('selected');
            
            if (game.selectedUnitType === 'goblin') {
                document.getElementById('goblinBtn').classList.add('selected');
            } else if (game.selectedUnitType === 'archer') {
                document.getElementById('archerBtn').classList.add('selected');
            } else if (game.selectedUnitType === 'shaman') {
                document.getElementById('shamanBtn').classList.add('selected');
            }
        }
        
        // Helper function to get valid placement hexes sorted by priority
        // Returns array of {hex, space} objects sorted by: empty hexes first, then hexes with space
        function getPlacementHexes(sourceHex, unitsToPlace) {
            const placementOptions = [];

            // Check source hex first
            const sourceSpace = 9 - sourceHex.units.length;
            if (sourceSpace > 0) {
                placementOptions.push({
                    hex: sourceHex,
                    space: sourceSpace,
                    isEmpty: sourceHex.units.length === 0,
                    isSource: true
                });
            }

            // Check adjacent hexes
            const neighbors = getNeighbors(sourceHex.q, sourceHex.r);
            for (const n of neighbors) {
                const hex = hexMap.get(`${n.q},${n.r}`);
                if (!hex || hex.type !== TILE_TYPES.LAND) continue;

                const currentUnits = hex.units.length;
                const spaceAvailable = 9 - currentUnits;

                // Accept empty hexes or friendly hexes with space
                if (currentUnits === 0 || (hex.owner === FACTIONS.PLAYER && spaceAvailable > 0)) {
                    placementOptions.push({
                        hex: hex,
                        space: spaceAvailable,
                        isEmpty: currentUnits === 0,
                        isSource: false
                    });
                }
            }

            // Sort by priority: source first if has space, then empty adjacent, then adjacent with space
            placementOptions.sort((a, b) => {
                // Source hex gets priority if it has space
                if (a.isSource && !b.isSource) return -1;
                if (!a.isSource && b.isSource) return 1;

                // Among non-source hexes, prioritize empty hexes
                if (a.isEmpty && !b.isEmpty) return -1;
                if (!a.isEmpty && b.isEmpty) return 1;

                // If both empty or both have units, prefer more space
                return b.space - a.space;
            });

            return placementOptions;
        }

        // Recruit units
        function recruitUnits() {
            if (game.gameOver) return;

            const unitCosts = {
                'goblin': { type: UNIT_TYPES.GOBLIN, cost: 5, count: 3, requiresFortress: false },
                'archer': { type: UNIT_TYPES.GOBLIN_ARCHER, cost: 5, count: 3, requiresFortress: true },
                'shaman': { type: UNIT_TYPES.GOBLIN_SHAMAN, cost: 8, count: 3, requiresFortress: true }
            };

            const selected = unitCosts[game.selectedUnitType];

            if (!selected) {
                selectedInfo.textContent = 'Please select a unit type first.';
                return;
            }

            // Check if fortress is required
            if (selected.requiresFortress && !playerHasFortress()) {
                selectedInfo.textContent = 'üîí This unit requires a Goblin Fortress! Upgrade your camp first (30g).';
                return;
            }

            if (game.resources.gold < selected.cost) {
                selectedInfo.textContent = `Not enough gold! Need ${selected.cost}g.`;
                return;
            }

            let currentUnits = 0;
            let maxSupply = 0;
            hexMap.forEach(hex => {
                if (hex.owner === FACTIONS.PLAYER) {
                    currentUnits += hex.units.length;
                    if (hex.building && hex.building.supplyBonus) {
                        maxSupply += hex.building.supplyBonus;
                    }
                }
            });

            if (currentUnits + selected.count > maxSupply) {
                selectedInfo.textContent = `Not enough supply! Current: ${currentUnits}/${maxSupply}`;
                return;
            }

            if (!game.playerStartHex || !game.playerStartHex.building || game.playerStartHex.owner !== FACTIONS.PLAYER) {
                selectedInfo.textContent = 'You need a base to recruit units!';
                return;
            }

            // Get valid placement hexes sorted by priority (empty first)
            const placementHexes = getPlacementHexes(game.playerStartHex, selected.count);

            if (placementHexes.length === 0) {
                selectedInfo.textContent = 'No space to place units! Base and adjacent hexes are full.';
                return;
            }

            // Place units across available hexes
            let unitsPlaced = 0;
            let placementDetails = [];

            for (const hexInfo of placementHexes) {
                const hex = hexInfo.hex;
                const spaceAvailable = hexInfo.space;
                const unitsToPlace = Math.min(spaceAvailable, selected.count - unitsPlaced);

                for (let i = 0; i < unitsToPlace; i++) {
                    hex.units.push(createUnit(selected.type));
                }

                if (hex !== game.playerStartHex) {
                    hex.owner = FACTIONS.PLAYER;
                    placementDetails.push(`${unitsToPlace} adjacent`);
                } else {
                    placementDetails.push(`${unitsToPlace} at base`);
                }

                unitsPlaced += unitsToPlace;

                if (unitsPlaced >= selected.count) break;
            }

            game.resources.gold -= selected.cost;
            selectedInfo.textContent = `Recruited ${selected.count} ${selected.type.name}(s) (${placementDetails.join(', ')})!`;
            updateUI();
            drawMap();
        }
        
        // End turn
        game.endTurn = function() {
            if (game.gameOver) return;
            
            game.movedUnits.clear();
            
            buildInterestingTilesCache();
            
            executeAITurn(FACTIONS.ANCIENT);
            executeAITurn(FACTIONS.BEAST);
            executeAITurn(FACTIONS.NATURE);
            
            executeAutoMovements();
            
            game.turn++;
            
            game.sunAngle += Math.PI / 4;
            if (game.sunAngle >= Math.PI * 2) {
                game.sunAngle -= Math.PI * 2;
            }
            
            processBuildings();

            processWreckedShips();

            checkLoseCondition();

            updateUI();
            drawMap();
        };
        
        // Mouse handling
        let hoveredHex = null;
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            game.mouseX = x;
            game.mouseY = y;

            const hex = pixelToHex(x, y);
            const key = `${hex.q},${hex.r}`;
            const hoveredTile = hexMap.get(key);

            if (hoveredTile) {
                hoveredHex = hoveredTile;

                // Building placement mode - highlight valid locations within 10 tiles
                if (game.buildingPlacementMode && game.selectedBuildingType) {
                    game.validBuildLocations = [];
                    hexMap.forEach(testHex => {
                        const distance = getHexDistance(hoveredTile.q, hoveredTile.r, testHex.q, testHex.r);
                        if (distance <= 10 && canBuildAt(testHex, game.selectedBuildingType)) {
                            game.validBuildLocations.push(testHex);
                        }
                    });

                    // Change cursor color based on whether building can be placed here
                    if (canBuildAt(hoveredTile, game.selectedBuildingType)) {
                        canvas.classList.add('cursor-valid');
                        canvas.classList.remove('cursor-invalid');
                    } else {
                        canvas.classList.add('cursor-invalid');
                        canvas.classList.remove('cursor-valid');
                    }
                } else if (game.selectedHex && game.selectionMode === 'unit' &&
                    game.selectedHex.owner === FACTIONS.PLAYER && game.selectedHex.units.length > 0) {
                    const distance = getHexDistance(game.selectedHex.q, game.selectedHex.r, hoveredTile.q, hoveredTile.r);

                    if (distance > 3 && hoveredTile.type === TILE_TYPES.LAND) {
                        const path = findPath(game.selectedHex, hoveredTile);
                        if (path && path.length > 0) {
                            game.hoveredPath = path;
                            hoveredHex.pathTurns = path[path.length - 1].turn;
                        } else {
                            game.hoveredPath = null;
                        }
                    } else {
                        game.hoveredPath = null;
                    }
                    // Reset cursor for normal mode
                    canvas.style.cursor = 'default';
                    canvas.classList.remove('cursor-valid', 'cursor-invalid');
                } else {
                    game.hoveredPath = null;
                    // Reset cursor
                    canvas.style.cursor = 'default';
                    canvas.classList.remove('cursor-valid', 'cursor-invalid');
                }
            } else {
                hoveredHex = null;
                game.hoveredPath = null;
                // Reset cursor when not hovering over any tile
                if (game.buildingPlacementMode) {
                    canvas.classList.add('cursor-invalid');
                    canvas.classList.remove('cursor-valid');
                } else {
                    canvas.style.cursor = 'default';
                    canvas.classList.remove('cursor-valid', 'cursor-invalid');
                }
            }

            if (isDragging) {
                targetOffsetX += (x - dragStartX) * 1.5;
                targetOffsetY += (y - dragStartY) * 1.5;
                dragStartX = x;
                dragStartY = y;
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                if (game.initialZooming) return; // Disable dragging during initial zoom
                isDragging = true;
                const rect = canvas.getBoundingClientRect();
                dragStartX = e.clientX - rect.left;
                dragStartY = e.clientY - rect.top;
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0 && isDragging) {
                isDragging = false;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dragDistance = Math.sqrt(
                    Math.pow(x - dragStartX, 2) + 
                    Math.pow(y - dragStartY, 2)
                );
                
                if (dragDistance < 5) {
                    handleHexClick(x, y);
                }
            }
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();

            // Cancel building placement mode if active
            if (game.buildingPlacementMode) {
                game.buildingPlacementMode = false;
                game.selectedBuildingType = null;
                game.validBuildLocations = [];
                canvas.style.cursor = 'default';
                canvas.classList.remove('cursor-valid', 'cursor-invalid');
                selectedInfo.textContent = 'Building placement cancelled.';
                updateBuildingButtonStates();
                drawMap();
                return;
            }

            game.selectedHex = null;
            game.validMoves = [];
            game.selectionMode = 'unit';
            selectedInfo.textContent = 'Right-click to deselect';
            updateActionButtonStates();
            drawMap();
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (game.initialZooming) return; // Disable zoom during initial zoom

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate world position at mouse cursor before zoom
            const worldX = (mouseX - canvas.width / 2 - targetOffsetX) / targetZoom;
            const worldY = (mouseY - canvas.height / 2 - targetOffsetY) / targetZoom;

            // Apply zoom change
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom * zoomFactor));

            // Calculate new offset so that the same world position stays under the cursor
            // worldX = (mouseX - canvas.width/2 - newOffsetX) / targetZoom
            // newOffsetX = mouseX - canvas.width/2 - worldX * targetZoom
            targetOffsetX = mouseX - canvas.width / 2 - worldX * targetZoom;
            targetOffsetY = mouseY - canvas.height / 2 - worldY * targetZoom;
        });
        
        // Handle hex click
        function handleHexClick(x, y) {
            if (game.gameOver) return;
            if (game.initialZooming) return; // Disable clicks during initial zoom

            const hex = pixelToHex(x, y);
            const key = `${hex.q},${hex.r}`;
            const clickedHex = hexMap.get(key);

            if (!clickedHex) return;

            // Building placement mode - try to place building
            if (game.buildingPlacementMode && game.selectedBuildingType) {
                placeBuildingAt(clickedHex, game.selectedBuildingType);
                return;
            }

            if (game.selectedHex && game.selectedHex.owner === FACTIONS.PLAYER) {
                const hexKey = `${game.selectedHex.q},${game.selectedHex.r}`;
                const hasMoved = game.movedUnits.has(hexKey);
                
                if (!hasMoved && clickedHex.type === TILE_TYPES.LAND) {
                    const distance = getHexDistance(game.selectedHex.q, game.selectedHex.r, clickedHex.q, clickedHex.r);
                    
                    // Check if this is a ranged attack (distance 2-3, has archers/shamans, enemy target)
                    const unitCounts = countUnitTypes(game.selectedHex.units);
                    const hasRangedUnits = unitCounts.archers > 0 || unitCounts.shamans > 0;
                    const isRangedDistance = distance > 1 && distance <= 3;
                    const isEnemyTarget = clickedHex.owner && clickedHex.owner !== FACTIONS.PLAYER && clickedHex.units.length > 0;
                    
                    if (hasRangedUnits && isRangedDistance && isEnemyTarget) {
                        // Perform ranged attack
                        const success = rangedAttack(game.selectedHex, clickedHex);
                        
                        if (success) {
                            selectedInfo.textContent = `Ranged attack executed! ${unitCounts.archers} archer(s) and ${unitCounts.shamans} shaman(s) attacked from range.`;
                            game.validMoves = [];
                        } else {
                            selectedInfo.textContent = 'Ranged attack failed.';
                        }
                        
                        updateUI();
                        drawMap();
                        return;
                    }
                    
                    // Check if clicking a valid adjacent move (within 3 hexes)
                    const isValidMove = game.validMoves.some(move => move.q === clickedHex.q && move.r === clickedHex.r);
                    
                    if (isValidMove && distance <= 3) {
                        // Immediate move
                        const success = moveUnits(game.selectedHex, clickedHex);
                        
                        if (success) {
                            game.selectedHex = clickedHex;
                            game.validMoves = [];
                        }
                        
                        updateUI();
                        drawMap();
                        return;
                    } else if (distance > 3) {
                        // Create a path for distant tiles
                        const path = findPath(game.selectedHex, clickedHex);
                        if (path) {
                            game.plannedPaths.set(hexKey, path);
                            const turns = path[path.length - 1].turn;
                            selectedInfo.textContent = `Movement queued! Will reach destination in ${turns} turn${turns > 1 ? 's' : ''}. Units move automatically each turn. Click unit again to cancel.`;
                        } else {
                            selectedInfo.textContent = 'Cannot find a valid path to that location.';
                        }
                        
                        updateUI();
                        drawMap();
                        return;
                    }
                }
            }
            
            // Allow selection of any hex with units or buildings (not just player-owned)
            const hexKey = `${clickedHex.q},${clickedHex.r}`;
            const hasUnits = clickedHex.units.length > 0;
            const hasBuilding = clickedHex.building !== null && clickedHex.building !== undefined;
            const isPlayerOwned = clickedHex.owner === FACTIONS.PLAYER;

            // Check if clicking the same hex - cancel path or cycle/deselect
            const isSameHex = game.selectedHex && game.selectedHex.q === clickedHex.q && game.selectedHex.r === clickedHex.r;

            if (isSameHex) {
                // Check if this unit has a planned path - cancel it if so
                const hexKey = `${clickedHex.q},${clickedHex.r}`;
                if (game.plannedPaths.has(hexKey)) {
                    game.plannedPaths.delete(hexKey);
                    selectedInfo.textContent = 'Queued path cancelled. Click again to deselect.';
                    updateUI();
                    drawMap();
                    return;
                }

                // No path, so cycle or deselect
                if (hasUnits && hasBuilding) {
                    // Cycle: unit ‚Üí building ‚Üí deselect
                    if (game.selectionMode === 'unit') {
                        game.selectionMode = 'building';
                    } else if (game.selectionMode === 'building') {
                        game.selectedHex = null;
                        game.validMoves = [];
                        game.selectionMode = 'unit';
                        selectedInfo.textContent = 'Deselected.';
                        updateActionButtonStates();
                        drawMap();
                        return;
                    }
                } else if (hasUnits || hasBuilding) {
                    // Only one thing to select, toggle deselect
                    game.selectedHex = null;
                    game.validMoves = [];
                    game.selectionMode = 'unit';
                    selectedInfo.textContent = 'Deselected.';
                    updateActionButtonStates();
                    drawMap();
                    return;
                }
            } else if (hasUnits || hasBuilding) {
                // New hex selected - start with units if available, otherwise building
                game.selectedHex = clickedHex;
                game.selectionMode = hasUnits ? 'unit' : 'building';
            } else {
                // Empty hex with nothing to select
                game.selectedHex = null;
                game.validMoves = [];
                game.selectionMode = 'unit';
                selectedInfo.textContent = 'This tile has no units or buildings.';
                updateActionButtonStates();
                drawMap();
                return;
            }

            const hasMoved = game.movedUnits.has(hexKey);

            // Display information based on selection mode
            if (game.selectionMode === 'unit' && hasUnits) {
                const unitCount = clickedHex.units.length;
                const unitType = clickedHex.units[0].name;
                const unitCounts = countUnitTypes(clickedHex.units);

                // Build unit composition string
                let unitComposition = '';
                if (unitCounts.goblins > 0) unitComposition += `${unitCounts.goblins} Goblin(s), `;
                if (unitCounts.archers > 0) unitComposition += `${unitCounts.archers} Archer(s), `;
                if (unitCounts.shamans > 0) unitComposition += `${unitCounts.shamans} Shaman(s), `;
                if (unitCounts.wolves > 0) unitComposition += `${unitCounts.wolves} Wolf/Wolves, `;
                if (unitCounts.bears > 0) unitComposition += `${unitCounts.bears} Bear(s), `;
                if (unitCounts.treants > 0) unitComposition += `${unitCounts.treants} Treant(s), `;
                if (unitCounts.golems > 0) unitComposition += `${unitCounts.golems} Golem(s), `;
                if (unitCounts.elementals > 0) unitComposition += `${unitCounts.elementals} Elemental(s), `;
                unitComposition = unitComposition.slice(0, -2); // Remove trailing comma

                // Calculate total HP and attack
                let totalHp = 0;
                let totalAttack = 0;
                clickedHex.units.forEach(unit => {
                    totalHp += unit.hp;
                    totalAttack += unit.attack;
                });

                if (isPlayerOwned) {
                    // Player units - allow actions
                    if (hasMoved) {
                        game.validMoves = [];
                        const existingPath = game.plannedPaths.get(hexKey);
                        if (existingPath && existingPath.length > 0) {
                            selectedInfo.textContent = `${unitComposition}. Total: ${totalHp} HP, ${totalAttack} ATK. Moved this turn. Path set for ${existingPath[existingPath.length - 1].turn} turns. Click unit again to cancel.`;
                        } else {
                            selectedInfo.textContent = `${unitComposition}. Total: ${totalHp} HP, ${totalAttack} ATK. Moved this turn.`;
                        }
                    } else {
                        game.validMoves = [];

                        // Add all tiles within 3 hexes as valid moves
                        const isOnDock = clickedHex.building && clickedHex.building.allowsNaval;
                        const isOnShip = clickedHex.type === TILE_TYPES.SEA && clickedHex.ship;

                        hexMap.forEach(hex => {
                            const distance = getHexDistance(clickedHex.q, clickedHex.r, hex.q, hex.r);
                            if (distance <= 3 && distance > 0) {
                                // If on a ship, allow water and adjacent land tiles
                                if (isOnShip) {
                                    if (hex.type === TILE_TYPES.SEA) {
                                        game.validMoves.push({ q: hex.q, r: hex.r });
                                    } else if (hex.type === TILE_TYPES.LAND && distance === 1) {
                                        game.validMoves.push({ q: hex.q, r: hex.r });
                                    }
                                }
                                // If on land
                                else {
                                    // Allow land tiles always
                                    if (hex.type === TILE_TYPES.LAND) {
                                        game.validMoves.push({ q: hex.q, r: hex.r });
                                    }
                                    // Allow water tiles if on a dock
                                    else if (hex.type === TILE_TYPES.SEA && isOnDock) {
                                        game.validMoves.push({ q: hex.q, r: hex.r });
                                    }
                                }
                            }
                        });

                        // Check if this unit has a planned path
                        const existingPath = game.plannedPaths.get(hexKey);
                        if (existingPath && existingPath.length > 0) {
                            selectedInfo.textContent = `${unitComposition}. Total: ${totalHp} HP, ${totalAttack} ATK. Path set for ${existingPath[existingPath.length - 1].turn} turns. Click unit again to cancel.`;
                        } else {
                            let moveText = `${unitComposition}. Total: ${totalHp} HP, ${totalAttack} ATK.`;
                            if (unitCounts.archers > 0 || unitCounts.shamans > 0) {
                                moveText += ` Can attack at range.`;
                            }
                            moveText += ` Click to move/attack.`;
                            if (hasBuilding) {
                                moveText += ` Click again for building.`;
                            }
                            selectedInfo.textContent = moveText;
                        }
                    }
                } else {
                    // Enemy units - info only
                    game.validMoves = [];
                    const factionName = clickedHex.owner ? clickedHex.owner.charAt(0).toUpperCase() + clickedHex.owner.slice(1) : 'Neutral';
                    selectedInfo.textContent = `${factionName}: ${unitComposition}. Total: ${totalHp} HP, ${totalAttack} ATK.`;
                    if (hasBuilding) {
                        selectedInfo.textContent += ` Click again for building info.`;
                    }
                }
            } else if (game.selectionMode === 'building' && hasBuilding) {
                game.validMoves = [];
                const building = clickedHex.building;
                const factionName = clickedHex.owner ? clickedHex.owner.charAt(0).toUpperCase() + clickedHex.owner.slice(1) : 'Neutral';

                let buildingText = `${factionName}: ${building.name}.`;

                // Add building stats
                if (building.produces) {
                    buildingText += ` Produces: ${building.produces.name}.`;
                }
                if (building.baseIncome) {
                    buildingText += ` Income: ${building.baseIncome.gold}g/turn.`;
                }
                if (building.resource) {
                    buildingText += ` Resource: ${building.amount} ${building.resource}/turn.`;
                }
                if (building.supplyBonus) {
                    buildingText += ` Supply: +${building.supplyBonus}.`;
                }

                // Only show upgrade option for player buildings
                if (isPlayerOwned && building.upgradeTo) {
                    const upgradeCost = building.upgradeCost.gold;
                    const upgradeName = BUILDING_TYPES[building.upgradeTo].name;
                    buildingText += ` Can upgrade to ${upgradeName} for ${upgradeCost}g. Press U.`;
                }

                if (hasUnits) {
                    buildingText += ` Click again for units.`;
                }
                selectedInfo.textContent = buildingText;
            }

            updateActionButtonStates();
            drawMap();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                // Toggle help overlay
                const helpOverlay = document.getElementById('helpOverlay');
                helpOverlay.classList.toggle('show');
            }
        });

        // Split army function
        function splitArmy() {
            if (game.gameOver) return;

            if (!game.selectedHex || game.selectedHex.owner !== FACTIONS.PLAYER) {
                selectedInfo.textContent = 'Select one of your armies to split.';
                return;
            }

            if (game.selectedHex.units.length < 2) {
                selectedInfo.textContent = 'Need at least 2 units to split an army.';
                return;
            }

            // Cannot split army on water
            if (game.selectedHex.type === TILE_TYPES.SEA) {
                selectedInfo.textContent = 'Cannot split army while on water!';
                return;
            }

            const hexKey = `${game.selectedHex.q},${game.selectedHex.r}`;
            if (game.movedUnits.has(hexKey)) {
                selectedInfo.textContent = 'Cannot split an army that has already moved this turn.';
                return;
            }

            // Calculate split size (half, rounded down)
            const totalUnits = game.selectedHex.units.length;
            const splitSize = Math.floor(totalUnits / 2);

            // Find valid adjacent hexes
            const neighbors = getNeighbors(game.selectedHex.q, game.selectedHex.r);
            const validTargets = neighbors
                .map(n => {
                    const hex = hexMap.get(`${n.q},${n.r}`);
                    if (!hex || hex.type !== TILE_TYPES.LAND) return null;

                    // Can split to empty hex or friendly hex with room
                    const isEmpty = hex.units.length === 0;
                    const hasFriendlySpace = hex.owner === FACTIONS.PLAYER && hex.units.length + splitSize <= 9;

                    if (isEmpty || hasFriendlySpace) {
                        return { coords: n, hex: hex, isEmpty: isEmpty };
                    }
                    return null;
                })
                .filter(t => t !== null)
                .sort((a, b) => {
                    // Prioritize empty hexes over hexes with units
                    if (a.isEmpty && !b.isEmpty) return -1;
                    if (!a.isEmpty && b.isEmpty) return 1;
                    // Among hexes with units, prefer those with fewer units
                    return a.hex.units.length - b.hex.units.length;
                });

            if (validTargets.length === 0) {
                selectedInfo.textContent = 'No valid adjacent hexes to split army to. Need empty or friendly hex with space.';
                return;
            }

            // Use the best target (prioritizes empty hexes)
            const targetInfo = validTargets[0];
            const targetHex = targetInfo.hex;

            // Split the units
            const splitUnits = game.selectedHex.units.splice(-splitSize, splitSize);

            // Move split units to target
            if (targetHex.units.length === 0) {
                targetHex.units = splitUnits;
                targetHex.owner = FACTIONS.PLAYER;
                targetHex.unitOrigins = game.selectedHex.unitOrigins;
            } else {
                targetHex.units = targetHex.units.concat(splitUnits);
            }

            // Create footprints
            const unitType = splitUnits[0];
            createFootprints(game.selectedHex, targetHex, splitUnits.length, FACTIONS.PLAYER, unitType);

            // Mark both hexes as moved
            game.movedUnits.add(hexKey);
            game.movedUnits.add(`${targetHex.q},${targetHex.r}`);

            const targetDescription = targetInfo.isEmpty ? 'empty' : 'friendly';
            selectedInfo.textContent = `Army split! ${splitSize} units moved to ${targetDescription} adjacent hex. Both groups have moved this turn.`;

            // Clear selection
            game.selectedHex = null;
            game.validMoves = [];

            updateUI();
            drawMap();
        }
        
        // Initialize game
        function initGame() {
            // Hide game over overlay
            document.getElementById('gameOverlay').classList.remove('show');

            // Re-enable controls
            document.getElementById('endTurnBtn').disabled = false;
            document.getElementById('splitBtn').disabled = false;
            document.getElementById('upgradeBtn').disabled = false;
            
            game.turn = 1;
            game.resources.gold = 10;
            game.aiResources = {
                [FACTIONS.ANCIENT]: { gold: 10 },
                [FACTIONS.BEAST]: { gold: 10 },
                [FACTIONS.NATURE]: { gold: 10 }
            };
            game.aiRecruitmentCooldown = {
                [FACTIONS.ANCIENT]: -999,
                [FACTIONS.BEAST]: -999,
                [FACTIONS.NATURE]: -999
            };
            game.selectedHex = null;
            game.validMoves = [];
            game.movedUnits.clear();
            game.footprints = [];
            game.skulls = [];
            game.plannedPaths.clear();
            game.hoveredPath = null;
            game.sunAngle = 0;
            game.selectedUnitType = 'goblin';
            game.landTilesCache = [];
            game.interestingTilesCache.clear();
            game.gameOver = false;
            game.showAllPaths = false;
            game.ships = [];
            game.wreckedShips = [];
            game.smokeParticles = [];
            game.towerSmokeTimers.clear();
            game.initialZooming = true;
            game.initialZoomStartTime = 0;

            // Hide welcome message if visible from previous game
            const welcomeMsg = document.getElementById('welcomeMessage');
            welcomeMsg.classList.remove('show', 'fade-out');

            generateMap();
            initBuildingCache(); // Initialize building sprite cache on first run
            resizeCanvas();
            updateUI();
            updateUnitButtonStates();
            animateMap();

            // Auto-zoom to player's starting position after 1 second
            setTimeout(() => {
                if (game.playerStartHex) {
                    // Calculate world coordinates directly from hex coordinates
                    const q = game.playerStartHex.q;
                    const r = game.playerStartHex.r;
                    const worldX = HEX_SIZE * Math.sqrt(3) * (q + r/2);
                    const worldY = HEX_SIZE * (3/2 * r);

                    const zoomLevel = 2.0; // Closer zoom level

                    // Set offsets to center on the goblin fort at the target zoom
                    targetOffsetX = -(worldX * zoomLevel);
                    targetOffsetY = -(worldY * zoomLevel);
                    targetZoom = zoomLevel;

                    // Start the initial zoom timer
                    game.initialZoomStartTime = Date.now();
                }
            }, 1000);
        }

        // Start game when DOM is fully loaded and layout is ready
        window.addEventListener('DOMContentLoaded', () => {
            // Cache sprites for performance
            cacheUnitSprites();
            cacheSkullSprites();
            cacheFootprintSprites();

            // Use requestAnimationFrame to ensure CSS layout is calculated
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    initGame();
                });
            });
        });
    </script>
</body>
</html>